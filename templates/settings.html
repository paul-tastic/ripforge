{% extends "base.html" %}

{% block title %}RipForge - Settings{% endblock %}
{% block page_title %}Settings{% endblock %}

{% block content %}
<div class="settings">
    <!-- Auto-detect Banner -->
    <section class="card auto-detect">
        <div class="auto-detect-content">
            <div>
                <h3>Auto-Detect Services</h3>
                <p>Scan for Docker containers and import existing API keys</p>
            </div>
            <button class="btn btn-primary" id="btn-auto-detect">
                <span class="btn-icon">üîç</span> Auto-Detect
            </button>
        </div>
    </section>

    <!-- Integrations -->
    <section class="card">
        <h2>Integrations</h2>

        <!-- Radarr -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="radarr-enabled" {% if config.integrations.radarr.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Radarr</span>
                <span class="integration-badge" id="radarr-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="radarr-url" value="{{ config.integrations.radarr.url }}" placeholder="http://localhost:7878">
                </div>
                <div class="field">
                    <label>API Key</label>
                    <input type="password" id="radarr-api" value="{{ config.integrations.radarr.api_key }}" placeholder="Enter API key">
                </div>
                <button class="btn btn-small" onclick="testConnection('radarr')">Test Connection</button>
            </div>
        </div>

        <!-- Sonarr -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="sonarr-enabled" {% if config.integrations.sonarr.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Sonarr</span>
                <span class="integration-badge" id="sonarr-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="sonarr-url" value="{{ config.integrations.sonarr.url }}" placeholder="http://localhost:8989">
                </div>
                <div class="field">
                    <label>API Key</label>
                    <input type="password" id="sonarr-api" value="{{ config.integrations.sonarr.api_key }}" placeholder="Enter API key">
                </div>
                <button class="btn btn-small" onclick="testConnection('sonarr')">Test Connection</button>
            </div>
        </div>

        <!-- Overseerr -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="overseerr-enabled" {% if config.integrations.overseerr.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Overseerr</span>
                <span class="integration-badge" id="overseerr-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="overseerr-url" value="{{ config.integrations.overseerr.url }}" placeholder="http://localhost:5055">
                </div>
                <div class="field">
                    <label>API Key</label>
                    <input type="password" id="overseerr-api" value="{{ config.integrations.overseerr.api_key }}" placeholder="Enter API key">
                </div>
                <button class="btn btn-small" onclick="testConnection('overseerr')">Test Connection</button>
            </div>
        </div>

        <!-- Plex -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="plex-enabled" {% if config.integrations.plex.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Plex</span>
                <span class="integration-badge" id="plex-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="plex-url" value="{{ config.integrations.plex.url }}" placeholder="http://localhost:32400">
                </div>
                <div class="field">
                    <label>Token</label>
                    <input type="password" id="plex-token" value="{{ config.integrations.plex.token }}" placeholder="Enter Plex token">
                </div>
                <button class="btn btn-small" onclick="testConnection('plex')">Test Connection</button>
            </div>
        </div>

        <!-- Tautulli -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="tautulli-enabled" {% if config.integrations.tautulli.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Tautulli</span>
                <span class="integration-badge" id="tautulli-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="tautulli-url" value="{{ config.integrations.tautulli.url }}" placeholder="http://localhost:8181">
                </div>
                <div class="field">
                    <label>API Key</label>
                    <input type="password" id="tautulli-api" value="{{ config.integrations.tautulli.api_key }}" placeholder="Enter API key">
                </div>
                <button class="btn btn-small" onclick="testConnection('tautulli')">Test Connection</button>
            </div>
        </div>
    </section>

    <!-- Ripping Settings -->
    <section class="card">
        <h2>Ripping Settings</h2>
        <div class="settings-grid">
            <div class="field">
                <label>Minimum Track Length (seconds)</label>
                <input type="number" id="min-length" value="{{ config.ripping.min_length }}">
                <small>Tracks shorter than this will be skipped (2700 = 45 min)</small>
            </div>
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="main-feature-only" {% if config.ripping.main_feature_only %}checked{% endif %}>
                    <span>Main Feature Only</span>
                </label>
                <small>Only rip the longest track (main movie)</small>
            </div>
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="skip-transcode" {% if config.ripping.skip_transcode %}checked{% endif %}>
                    <span>Skip Transcoding</span>
                </label>
                <small>Keep original MakeMKV quality</small>
            </div>
            <div class="field rip-mode-field">
                <label>Rip Mode</label>
                <select id="rip-mode">
                    <option value="smart" {% if config.ripping.rip_mode == 'smart' or not config.ripping.rip_mode %}selected{% endif %}>Smart (Recommended)</option>
                    <option value="always_backup" {% if config.ripping.rip_mode == 'always_backup' %}selected{% endif %}>Always Backup</option>
                    <option value="direct_only" {% if config.ripping.rip_mode == 'direct_only' %}selected{% endif %}>Direct Only</option>
                </select>
                <small id="rip-mode-desc">Try direct first, auto-fallback to backup if copy protection detected</small>
            </div>
        </div>
        <div class="rip-mode-info" id="rip-mode-info">
            <div class="mode-details" id="mode-smart">
                <strong>Smart:</strong> Tries direct rip first (fastest). If copy protection is detected, automatically retries via backup method.
            </div>
            <div class="mode-details" id="mode-always_backup" style="display:none;">
                <strong>Always Backup:</strong> Decrypts full disc first (~50GB temp space), then extracts. Best for Blu-ray, Star Wars, Disney, and copy-protected discs. More accurate track identification.
            </div>
            <div class="mode-details" id="mode-direct_only" style="display:none;">
                <strong>Direct Only:</strong> Fastest method, no fallback. Best for DVDs and unprotected discs.
            </div>
        </div>
    </section>

    <!-- Auto-Rip Settings -->
    <section class="card">
        <h2>Auto-Rip</h2>
        <p class="card-description">Configure automatic scanning and ripping behavior</p>
        <div class="settings-grid">
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="auto-scan-on-insert" {% if config.ripping.auto_scan_on_insert != false %}checked{% endif %}>
                    <span>Auto-Scan on Disc Insert</span>
                </label>
                <small>Automatically scan when a disc is inserted</small>
            </div>
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="auto-rip" {% if config.ripping.auto_rip != false %}checked{% endif %}>
                    <span>Auto-Rip After Scan</span>
                </label>
                <small>Start ripping automatically after countdown</small>
            </div>
            <div class="field">
                <label>Auto-Rip Countdown (seconds)</label>
                <input type="number" id="auto-rip-delay" value="{{ config.ripping.auto_rip_delay if config.ripping.auto_rip_delay is not none else 20 }}" min="0" max="120">
                <small>Time to review before auto-rip starts (0 = immediate)</small>
            </div>
            <div class="field">
                <label>Confidence Threshold (%)</label>
                <input type="number" id="confidence-threshold" value="{{ config.ripping.confidence_threshold if config.ripping.confidence_threshold is not none else 75 }}" min="0" max="100">
                <small>Below this, disc needs manual review before ripping</small>
            </div>
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="notify-uncertain" {% if config.ripping.notify_uncertain != false %}checked{% endif %}>
                    <span>Email on Uncertain ID</span>
                </label>
                <small>Send email when disc identification needs review</small>
            </div>
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="eject-when-done" {% if config.ripping.eject_when_done %}checked{% endif %}>
                    <span>Eject Disc When Done</span>
                </label>
                <small>Automatically eject disc after ripping completes</small>
            </div>
        </div>
    </section>

    <!-- Paths -->
    <section class="card">
        <h2>Paths</h2>
        <div class="settings-grid">
            <div class="field">
                <label>Raw Rips</label>
                <input type="text" id="path-raw" value="{{ config.paths.raw_rips }}">
            </div>
            <div class="field">
                <label>Movies Library</label>
                <input type="text" id="path-movies" value="{{ config.paths.movies }}">
            </div>
            <div class="field">
                <label>TV Library</label>
                <input type="text" id="path-tv" value="{{ config.paths.tv }}">
            </div>
        </div>
    </section>

    <!-- Notifications -->
    <section class="card">
        <h2>Email Notifications</h2>
        <p style="color: var(--text-muted); margin-bottom: 16px;">
            Manage email recipients, notification events, and weekly digest settings.
        </p>
        <a href="/notifications" class="btn btn-primary">
            Go to Notifications Settings
        </a>
    </section>

    <!-- Updates -->
    <section class="card">
        <h2>Updates</h2>
        <div class="update-status">
            <div class="update-info">
                <span class="update-label">Current version:</span>
                <span id="current-version">Loading...</span>
                <span class="version-dot" id="settings-version-dot" title="Checking...">‚óè</span>
            </div>
            <div class="update-info" id="latest-version-row" style="display: none;">
                <span class="update-label">Latest version:</span>
                <span id="latest-version">-</span>
            </div>
            <div class="update-info" id="last-check-row">
                <span class="update-label">Last checked:</span>
                <span id="last-check-time">Never</span>
            </div>
            <div class="update-actions">
                <button class="btn btn-secondary" id="btn-check-updates">Check Now</button>
                <button class="btn btn-update" id="btn-settings-update" style="display: none;">Install Update</button>
            </div>
        </div>
    </section>

    <!-- Save Button -->
    <div class="settings-actions">
        <button class="btn btn-primary btn-large" id="btn-save">
            <span class="btn-icon">üíæ</span> Save Settings
        </button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>

    // Auto-detect button
    document.getElementById('btn-auto-detect').addEventListener('click', function() {
        this.disabled = true;
        this.innerHTML = '<span class="btn-icon">‚è≥</span> Detecting...';

        fetch('/api/auto-detect', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                console.log('Auto-detect result:', data);

                const numServices = Object.keys(data.services).length;
                const numKeys = Object.keys(data.keys).length;

                if (data.applied) {
                    // Settings were saved - reload the page to show new values
                    showToast('Auto-detection complete! Found ' + numServices + ' services and ' + numKeys + ' API keys. Reloading...', 'success');
                    setTimeout(() => window.location.reload(), 1500);
                } else {
                    // Fill in detected services (fallback if not auto-saved)
                    for (const [service, info] of Object.entries(data.services)) {
                        if (info.detected) {
                            document.getElementById(service + '-url').value = info.url;
                            document.getElementById(service + '-enabled').checked = true;
                        }
                    }

                    if (data.keys.radarr_api) {
                        document.getElementById('radarr-api').value = data.keys.radarr_api;
                    }
                    if (data.keys.sonarr_api) {
                        document.getElementById('sonarr-api').value = data.keys.sonarr_api;
                    }
                    if (data.keys.plex_token) {
                        document.getElementById('plex-token').value = data.keys.plex_token;
                    }
                    if (data.keys.tautulli_api) {
                        document.getElementById('tautulli-api').value = data.keys.tautulli_api;
                    }

                    showToast('Auto-detection complete! Found ' + numServices + ' services and ' + numKeys + ' API keys. Click Save to apply.', 'success');
                }
            })
            .catch(err => {
                console.error('Auto-detect error:', err);
                showToast('Error during auto-detection', 'error');
            })
            .finally(() => {
                this.disabled = false;
                this.innerHTML = '<span class="btn-icon">üîç</span> Auto-Detect';
            });
    });

    // Test connection
    function testConnection(service) {
        const url = document.getElementById(service + '-url').value;
        const apiKey = document.getElementById(service + '-api')?.value || '';
        const token = document.getElementById(service + '-token')?.value || '';
        const badge = document.getElementById(service + '-status');

        badge.textContent = 'Testing...';
        badge.className = 'integration-badge testing';

        fetch('/api/test-connection', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ service, url, api_key: apiKey, token })
        })
        .then(r => r.json())
        .then(data => {
            if (data.connected) {
                badge.textContent = 'Connected' + (data.version ? ' (v' + data.version + ')' : '');
                badge.className = 'integration-badge connected';
            } else {
                badge.textContent = 'Failed';
                badge.className = 'integration-badge error';
            }
        })
        .catch(err => {
            badge.textContent = 'Error';
            badge.className = 'integration-badge error';
        });
    }

    // Version check
    function checkForUpdates(showToastOnNoUpdate = false) {
        const checkBtn = document.getElementById('btn-check-updates');
        const dotEl = document.getElementById('settings-version-dot');
        checkBtn.disabled = true;
        checkBtn.textContent = 'Checking...';

        fetch('/api/version')
            .then(r => r.json())
            .then(data => {
                document.getElementById('current-version').textContent = 'v' + data.current_version;

                // Store check time and result for dashboard
                const now = new Date();
                localStorage.setItem('ripforge_last_update_check', now.toISOString());
                localStorage.setItem('ripforge_update_available', data.update_available ? 'true' : 'false');
                localStorage.setItem('ripforge_latest_version', data.latest_version || '');
                document.getElementById('last-check-time').textContent = now.toLocaleString();

                if (data.error) {
                    dotEl.className = 'version-dot unknown';
                    dotEl.title = 'Unable to check for updates';
                    if (showToastOnNoUpdate) showToast('Unable to check for updates', 'error');
                } else if (data.update_available) {
                    dotEl.className = 'version-dot update-available';
                    dotEl.title = 'Update available: v' + data.latest_version;
                    document.getElementById('latest-version-row').style.display = 'flex';
                    document.getElementById('latest-version').textContent = 'v' + data.latest_version;
                    document.getElementById('btn-settings-update').style.display = 'inline-block';
                    showToast('Update available: v' + data.latest_version, 'success');
                } else {
                    dotEl.className = 'version-dot up-to-date';
                    dotEl.title = 'Up to date';
                    document.getElementById('latest-version-row').style.display = 'none';
                    document.getElementById('btn-settings-update').style.display = 'none';
                    if (showToastOnNoUpdate) showToast('You are running the latest version', 'success');
                }
            })
            .catch(err => {
                console.error('Error checking version:', err);
                if (showToastOnNoUpdate) showToast('Error checking for updates', 'error');
            })
            .finally(() => {
                checkBtn.disabled = false;
                checkBtn.textContent = 'Check Now';
            });
    }

    // Install update
    function performUpdate() {
        const updateBtn = document.getElementById('btn-settings-update');
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';

        fetch('/api/update', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    showToast('Update installed!', 'success');
                    countdownReload(updateBtn, 5);
                } else {
                    showToast('Update failed: ' + (data.error || 'Unknown error'), 'error');
                    updateBtn.disabled = false;
                    updateBtn.textContent = 'Install Update';
                }
            })
            .catch(err => {
                // Connection lost likely means service restarted
                countdownReload(updateBtn, 5);
            });
    }

    function countdownReload(btn, seconds) {
        let remaining = seconds;
        btn.textContent = `Restarting ${remaining}...`;
        const interval = setInterval(() => {
            remaining--;
            if (remaining > 0) {
                btn.textContent = `Restarting ${remaining}...`;
            } else {
                clearInterval(interval);
                btn.textContent = 'Reloading...';
                window.location.reload();
            }
        }, 1000);
    }

    // Load cached data on page load (no API call)
    function loadCachedVersion() {
        const lastCheck = localStorage.getItem('ripforge_last_update_check');
        const cachedUpdate = localStorage.getItem('ripforge_update_available');
        const cachedLatest = localStorage.getItem('ripforge_latest_version');
        const dotEl = document.getElementById('settings-version-dot');

        if (lastCheck) {
            document.getElementById('last-check-time').textContent = new Date(lastCheck).toLocaleString();
        }

        // Get current version from a quick API call (no GitHub check)
        fetch('/api/version')
            .then(r => r.json())
            .then(data => {
                document.getElementById('current-version').textContent = 'v' + data.current_version;

                // Use cached update status, but verify it's still valid
                const updateAvailable = cachedUpdate === 'true' && cachedLatest && cachedLatest !== data.current_version;

                if (updateAvailable) {
                    dotEl.className = 'version-dot update-available';
                    dotEl.title = 'Update available: v' + cachedLatest;
                    document.getElementById('latest-version-row').style.display = 'flex';
                    document.getElementById('latest-version').textContent = 'v' + cachedLatest;
                    document.getElementById('btn-settings-update').style.display = 'inline-block';
                } else {
                    dotEl.className = 'version-dot up-to-date';
                    dotEl.title = 'Up to date';
                    document.getElementById('latest-version-row').style.display = 'none';
                    document.getElementById('btn-settings-update').style.display = 'none';
                }
            });
    }

    loadCachedVersion();

    // Button handlers
    document.getElementById('btn-check-updates').addEventListener('click', () => checkForUpdates(true));
    document.getElementById('btn-settings-update').addEventListener('click', performUpdate);

    // Rip mode selector
    function updateRipModeInfo() {
        const mode = document.getElementById('rip-mode').value;
        document.querySelectorAll('.mode-details').forEach(el => el.style.display = 'none');
        document.getElementById('mode-' + mode).style.display = 'block';
    }
    document.getElementById('rip-mode').addEventListener('change', updateRipModeInfo);
    updateRipModeInfo(); // Set initial state

    // Save settings
    document.getElementById('btn-save').addEventListener('click', function() {
        const settings = {
            integrations: {
                radarr: {
                    enabled: document.getElementById('radarr-enabled').checked,
                    url: document.getElementById('radarr-url').value,
                    api_key: document.getElementById('radarr-api').value
                },
                sonarr: {
                    enabled: document.getElementById('sonarr-enabled').checked,
                    url: document.getElementById('sonarr-url').value,
                    api_key: document.getElementById('sonarr-api').value
                },
                overseerr: {
                    enabled: document.getElementById('overseerr-enabled').checked,
                    url: document.getElementById('overseerr-url').value,
                    api_key: document.getElementById('overseerr-api').value
                },
                plex: {
                    enabled: document.getElementById('plex-enabled').checked,
                    url: document.getElementById('plex-url').value,
                    token: document.getElementById('plex-token').value
                },
                tautulli: {
                    enabled: document.getElementById('tautulli-enabled').checked,
                    url: document.getElementById('tautulli-url').value,
                    api_key: document.getElementById('tautulli-api').value
                }
            },
            ripping: {
                min_length: parseInt(document.getElementById('min-length').value),
                main_feature_only: document.getElementById('main-feature-only').checked,
                skip_transcode: document.getElementById('skip-transcode').checked,
                rip_mode: document.getElementById('rip-mode').value,
                auto_scan_on_insert: document.getElementById('auto-scan-on-insert').checked,
                auto_rip: document.getElementById('auto-rip').checked,
                auto_rip_delay: parseInt(document.getElementById('auto-rip-delay').value),
                confidence_threshold: parseInt(document.getElementById('confidence-threshold').value),
                notify_uncertain: document.getElementById('notify-uncertain').checked,
                eject_when_done: document.getElementById('eject-when-done').checked
            },
            paths: {
                raw_rips: document.getElementById('path-raw').value,
                movies: document.getElementById('path-movies').value,
                tv: document.getElementById('path-tv').value
            }
        };

        fetch('/api/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings)
        })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                showToast('Settings saved!', 'success');
            }
        })
        .catch(err => {
            showToast('Error saving settings', 'error');
        });
    });
</script>
{% endblock %}
