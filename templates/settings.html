{% extends "base.html" %}

{% block title %}RipForge - Settings{% endblock %}
{% block page_title %}Settings{% endblock %}

{% block content %}
<div class="settings">
    <!-- Auto-detect Banner -->
    <section class="card auto-detect">
        <div class="auto-detect-content">
            <div>
                <h3>Auto-Detect Services</h3>
                <p>Scan for Docker containers and import existing API keys</p>
            </div>
            <button class="btn btn-primary" id="btn-auto-detect">
                <span class="btn-icon">üîç</span> Auto-Detect
            </button>
        </div>
    </section>

    <!-- Integrations -->
    <section class="card">
        <h2>Integrations</h2>

        <!-- Radarr -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="radarr-enabled" {% if config.integrations.radarr.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Radarr</span>
                <span class="integration-badge" id="radarr-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="radarr-url" value="{{ config.integrations.radarr.url }}" placeholder="http://localhost:7878">
                </div>
                <div class="field">
                    <label>API Key</label>
                    <input type="password" id="radarr-api" value="{{ config.integrations.radarr.api_key }}" placeholder="Enter API key">
                </div>
                <button class="btn btn-small" onclick="testConnection('radarr')">Test Connection</button>
            </div>
        </div>

        <!-- Sonarr -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="sonarr-enabled" {% if config.integrations.sonarr.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Sonarr</span>
                <span class="integration-badge" id="sonarr-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="sonarr-url" value="{{ config.integrations.sonarr.url }}" placeholder="http://localhost:8989">
                </div>
                <div class="field">
                    <label>API Key</label>
                    <input type="password" id="sonarr-api" value="{{ config.integrations.sonarr.api_key }}" placeholder="Enter API key">
                </div>
                <button class="btn btn-small" onclick="testConnection('sonarr')">Test Connection</button>
            </div>
        </div>

        <!-- Overseerr -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="overseerr-enabled" {% if config.integrations.overseerr.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Overseerr</span>
                <span class="integration-badge" id="overseerr-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="overseerr-url" value="{{ config.integrations.overseerr.url }}" placeholder="http://localhost:5055">
                </div>
                <div class="field">
                    <label>API Key</label>
                    <input type="password" id="overseerr-api" value="{{ config.integrations.overseerr.api_key }}" placeholder="Enter API key">
                </div>
                <button class="btn btn-small" onclick="testConnection('overseerr')">Test Connection</button>
            </div>
        </div>

        <!-- Plex -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="plex-enabled" {% if config.integrations.plex.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Plex</span>
                <span class="integration-badge" id="plex-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="plex-url" value="{{ config.integrations.plex.url }}" placeholder="http://localhost:32400">
                </div>
                <div class="field">
                    <label>Token</label>
                    <input type="password" id="plex-token" value="{{ config.integrations.plex.token }}" placeholder="Enter Plex token">
                </div>
                <button class="btn btn-small" onclick="testConnection('plex')">Test Connection</button>
            </div>
        </div>

        <!-- Tautulli -->
        <div class="integration-config">
            <div class="integration-header">
                <label class="toggle">
                    <input type="checkbox" id="tautulli-enabled" {% if config.integrations.tautulli.enabled %}checked{% endif %}>
                    <span class="toggle-slider"></span>
                </label>
                <span class="integration-title">Tautulli</span>
                <span class="integration-badge" id="tautulli-status">Not tested</span>
            </div>
            <div class="integration-fields">
                <div class="field">
                    <label>URL</label>
                    <input type="text" id="tautulli-url" value="{{ config.integrations.tautulli.url }}" placeholder="http://localhost:8181">
                </div>
                <div class="field">
                    <label>API Key</label>
                    <input type="password" id="tautulli-api" value="{{ config.integrations.tautulli.api_key }}" placeholder="Enter API key">
                </div>
                <button class="btn btn-small" onclick="testConnection('tautulli')">Test Connection</button>
            </div>
        </div>
    </section>

    <!-- Ripping Settings -->
    <section class="card">
        <h2>Ripping Settings</h2>
        <div class="settings-grid">
            <div class="field">
                <label>Minimum Track Length (seconds)</label>
                <input type="number" id="min-length" value="{{ config.ripping.min_length }}">
                <small>Tracks shorter than this will be skipped (2700 = 45 min)</small>
            </div>
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="main-feature-only" {% if config.ripping.main_feature_only %}checked{% endif %}>
                    <span>Main Feature Only</span>
                </label>
                <small>Only rip the longest track (main movie)</small>
            </div>
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="skip-transcode" {% if config.ripping.skip_transcode %}checked{% endif %}>
                    <span>Skip Transcoding</span>
                </label>
                <small>Keep original MakeMKV quality</small>
            </div>
        </div>
    </section>

    <!-- Auto-Rip Settings -->
    <section class="card">
        <h2>Auto-Rip</h2>
        <p class="card-description">Configure automatic scanning and ripping behavior</p>
        <div class="settings-grid">
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="auto-scan-on-insert" {% if config.ripping.auto_scan_on_insert != false %}checked{% endif %}>
                    <span>Auto-Scan on Disc Insert</span>
                </label>
                <small>Automatically scan when a disc is inserted</small>
            </div>
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="auto-rip" {% if config.ripping.auto_rip != false %}checked{% endif %}>
                    <span>Auto-Rip After Scan</span>
                </label>
                <small>Start ripping automatically after countdown</small>
            </div>
            <div class="field">
                <label>Auto-Rip Countdown (seconds)</label>
                <input type="number" id="auto-rip-delay" value="{{ config.ripping.auto_rip_delay or 20 }}" min="5" max="120">
                <small>Time to review before auto-rip starts</small>
            </div>
            <div class="field">
                <label>Confidence Threshold (%)</label>
                <input type="number" id="confidence-threshold" value="{{ config.ripping.confidence_threshold or 75 }}" min="0" max="100">
                <small>Below this, disc needs manual review before ripping</small>
            </div>
            <div class="field">
                <label class="toggle-label">
                    <input type="checkbox" id="notify-uncertain" {% if config.ripping.notify_uncertain != false %}checked{% endif %}>
                    <span>Email on Uncertain ID</span>
                </label>
                <small>Send email when disc identification needs review</small>
            </div>
        </div>
    </section>

    <!-- Paths -->
    <section class="card">
        <h2>Paths</h2>
        <div class="settings-grid">
            <div class="field">
                <label>Raw Rips</label>
                <input type="text" id="path-raw" value="{{ config.paths.raw_rips }}">
            </div>
            <div class="field">
                <label>Movies Library</label>
                <input type="text" id="path-movies" value="{{ config.paths.movies }}">
            </div>
            <div class="field">
                <label>TV Library</label>
                <input type="text" id="path-tv" value="{{ config.paths.tv }}">
            </div>
        </div>
    </section>

    <!-- Notifications -->
    <section class="card">
        <h2>Email Notifications</h2>

        <div class="notification-config">
            <h3 style="color: var(--text-muted); font-size: 14px; margin-bottom: 16px;">Recipients</h3>

            <!-- Plex Users -->
            <div class="recipient-list" id="plex-users-list">
                <div class="recipient-loading">Loading Plex users...</div>
            </div>

            <!-- Manual Recipients -->
            <div class="field" style="margin-top: 16px; margin-bottom: 20px;">
                <label style="color: var(--text-muted); font-size: 12px;">Additional Recipients</label>
                <input type="text" id="notify-recipients-manual" value="" placeholder="extra@example.com, another@example.com">
                <small>Additional addresses not from Plex (comma-separated)</small>
            </div>

            <h3 style="color: var(--text-muted); font-size: 14px; margin-bottom: 16px;">Notification Events</h3>
            <div class="settings-grid" style="margin-bottom: 20px;">
                <div class="field">
                    <label class="toggle-label">
                        <input type="checkbox" id="notify-complete" {% if config.notifications.email.on_complete %}checked{% endif %}>
                        <span>Email on Rip Complete</span>
                    </label>
                    <small>Send email when a disc finishes ripping</small>
                </div>
                <div class="field">
                    <label class="toggle-label">
                        <input type="checkbox" id="notify-error" {% if config.notifications.email.on_error %}checked{% endif %}>
                        <span>Email on Error</span>
                    </label>
                    <small>Send email if ripping fails</small>
                </div>
                <div class="field">
                    <label class="toggle-label">
                        <input type="checkbox" id="notify-weekly" {% if config.notifications.email.weekly_recap %}checked{% endif %}>
                        <span>Weekly Recap</span>
                    </label>
                    <small>Send weekly summary of ripping activity</small>
                </div>
            </div>

            <h3 style="color: var(--text-muted); font-size: 14px; margin-bottom: 16px;">Test Email</h3>
            <div class="email-test-buttons">
                <button class="btn btn-small" id="btn-test-email" onclick="testEmail()">
                    Send Test Email
                </button>
                <button class="btn btn-small btn-secondary" id="btn-test-recap" onclick="testWeeklyRecap()">
                    Send Weekly Recap Now
                </button>
                <span class="email-test-status" id="email-test-status"></span>
            </div>
        </div>
    </section>

    <!-- Save Button -->
    <div class="settings-actions">
        <button class="btn btn-primary btn-large" id="btn-save">
            <span class="btn-icon">üíæ</span> Save Settings
        </button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Store Plex users and their enabled state
    let plexUsers = [];
    const configuredRecipients = {{ config.notifications.email.recipients | tojson | safe }};

    // Load Plex users on page load
    function loadPlexUsers() {
        fetch('/api/plex/users')
            .then(r => r.json())
            .then(data => {
                plexUsers = data.users || [];
                renderPlexUsers();
            })
            .catch(err => {
                console.error('Error loading Plex users:', err);
                document.getElementById('plex-users-list').innerHTML =
                    '<div class="recipient-error">Could not load Plex users</div>';
            });
    }

    function renderPlexUsers() {
        const container = document.getElementById('plex-users-list');

        if (plexUsers.length === 0) {
            container.innerHTML = '<div class="recipient-empty">No Plex users found</div>';
        } else {
            let html = '';
            plexUsers.forEach((user, idx) => {
                // Check if this email is in the configured recipients
                const isEnabled = configuredRecipients.includes(user.email);
                const typeLabel = user.type === 'owner' ? 'Owner' : (user.type === 'home' ? 'Home' : 'Friend');

                html += `
                    <div class="recipient-item">
                        <label class="recipient-checkbox">
                            <input type="checkbox" class="plex-user-checkbox" data-email="${user.email}" ${isEnabled ? 'checked' : ''}>
                            <span class="recipient-info">
                                <span class="recipient-email">${user.email}</span>
                                <span class="recipient-meta">
                                    <span class="recipient-username">${user.username}</span>
                                    <span class="recipient-type">${typeLabel}</span>
                                </span>
                            </span>
                        </label>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Populate "Additional Recipients" with configured emails not from Plex
        const plexEmails = plexUsers.map(u => u.email);
        const nonPlexRecipients = configuredRecipients.filter(email => !plexEmails.includes(email));
        document.getElementById('notify-recipients-manual').value = nonPlexRecipients.join(', ');
    }

    // Get all selected recipients (Plex users + manual)
    function getSelectedRecipients() {
        const recipients = [];

        // Get enabled Plex users
        document.querySelectorAll('.plex-user-checkbox:checked').forEach(cb => {
            recipients.push(cb.dataset.email);
        });

        // Get manual recipients
        const manual = document.getElementById('notify-recipients-manual').value;
        if (manual) {
            manual.split(',').map(s => s.trim()).filter(s => s).forEach(email => {
                if (!recipients.includes(email)) {
                    recipients.push(email);
                }
            });
        }

        return recipients;
    }

    // Initialize on page load
    loadPlexUsers();

    // Auto-detect button
    document.getElementById('btn-auto-detect').addEventListener('click', function() {
        this.disabled = true;
        this.innerHTML = '<span class="btn-icon">‚è≥</span> Detecting...';

        fetch('/api/auto-detect', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                console.log('Auto-detect result:', data);

                const numServices = Object.keys(data.services).length;
                const numKeys = Object.keys(data.keys).length;

                if (data.applied) {
                    // Settings were saved - reload the page to show new values
                    alert('Auto-detection complete! Found ' + numServices + ' services and ' + numKeys + ' API keys. Settings saved - reloading page...');
                    window.location.reload();
                } else {
                    // Fill in detected services (fallback if not auto-saved)
                    for (const [service, info] of Object.entries(data.services)) {
                        if (info.detected) {
                            document.getElementById(service + '-url').value = info.url;
                            document.getElementById(service + '-enabled').checked = true;
                        }
                    }

                    if (data.keys.radarr_api) {
                        document.getElementById('radarr-api').value = data.keys.radarr_api;
                    }
                    if (data.keys.sonarr_api) {
                        document.getElementById('sonarr-api').value = data.keys.sonarr_api;
                    }
                    if (data.keys.plex_token) {
                        document.getElementById('plex-token').value = data.keys.plex_token;
                    }
                    if (data.keys.tautulli_api) {
                        document.getElementById('tautulli-api').value = data.keys.tautulli_api;
                    }

                    alert('Auto-detection complete! Found ' + numServices + ' services and ' + numKeys + ' API keys. Click Save to apply.');
                }
            })
            .catch(err => {
                console.error('Auto-detect error:', err);
                alert('Error during auto-detection');
            })
            .finally(() => {
                this.disabled = false;
                this.innerHTML = '<span class="btn-icon">üîç</span> Auto-Detect';
            });
    });

    // Test connection
    function testConnection(service) {
        const url = document.getElementById(service + '-url').value;
        const apiKey = document.getElementById(service + '-api')?.value || '';
        const token = document.getElementById(service + '-token')?.value || '';
        const badge = document.getElementById(service + '-status');

        badge.textContent = 'Testing...';
        badge.className = 'integration-badge testing';

        fetch('/api/test-connection', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ service, url, api_key: apiKey, token })
        })
        .then(r => r.json())
        .then(data => {
            if (data.connected) {
                badge.textContent = 'Connected' + (data.version ? ' (v' + data.version + ')' : '');
                badge.className = 'integration-badge connected';
            } else {
                badge.textContent = 'Failed';
                badge.className = 'integration-badge error';
            }
        })
        .catch(err => {
            badge.textContent = 'Error';
            badge.className = 'integration-badge error';
        });
    }

    // Test email
    function testEmail() {
        const btn = document.getElementById('btn-test-email');
        const status = document.getElementById('email-test-status');
        btn.disabled = true;
        btn.textContent = 'Sending...';
        status.textContent = '';
        status.className = 'email-test-status';

        const recipients = getSelectedRecipients();

        if (recipients.length === 0) {
            status.textContent = 'No recipients selected';
            status.className = 'email-test-status error';
            btn.disabled = false;
            btn.textContent = 'Send Test Email';
            return;
        }

        fetch('/api/email/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ recipients })
        })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                status.textContent = 'Email sent!';
                status.className = 'email-test-status success';
            } else {
                status.textContent = data.error || 'Failed';
                status.className = 'email-test-status error';
            }
        })
        .catch(err => {
            status.textContent = 'Error';
            status.className = 'email-test-status error';
        })
        .finally(() => {
            btn.disabled = false;
            btn.textContent = 'Send Test Email';
        });
    }

    // Test weekly recap
    function testWeeklyRecap() {
        const btn = document.getElementById('btn-test-recap');
        const status = document.getElementById('email-test-status');
        btn.disabled = true;
        btn.textContent = 'Sending...';
        status.textContent = '';
        status.className = 'email-test-status';

        const recipients = getSelectedRecipients();

        if (recipients.length === 0) {
            status.textContent = 'No recipients selected';
            status.className = 'email-test-status error';
            btn.disabled = false;
            btn.textContent = 'Send Weekly Recap Now';
            return;
        }

        fetch('/api/email/weekly-recap', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ recipients })
        })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                status.textContent = 'Recap sent!';
                status.className = 'email-test-status success';
            } else {
                status.textContent = data.error || 'Failed';
                status.className = 'email-test-status error';
            }
        })
        .catch(err => {
            status.textContent = 'Error';
            status.className = 'email-test-status error';
        })
        .finally(() => {
            btn.disabled = false;
            btn.textContent = 'Send Weekly Recap Now';
        });
    }

    // Save settings
    document.getElementById('btn-save').addEventListener('click', function() {
        const settings = {
            integrations: {
                radarr: {
                    enabled: document.getElementById('radarr-enabled').checked,
                    url: document.getElementById('radarr-url').value,
                    api_key: document.getElementById('radarr-api').value
                },
                sonarr: {
                    enabled: document.getElementById('sonarr-enabled').checked,
                    url: document.getElementById('sonarr-url').value,
                    api_key: document.getElementById('sonarr-api').value
                },
                overseerr: {
                    enabled: document.getElementById('overseerr-enabled').checked,
                    url: document.getElementById('overseerr-url').value,
                    api_key: document.getElementById('overseerr-api').value
                },
                plex: {
                    enabled: document.getElementById('plex-enabled').checked,
                    url: document.getElementById('plex-url').value,
                    token: document.getElementById('plex-token').value
                },
                tautulli: {
                    enabled: document.getElementById('tautulli-enabled').checked,
                    url: document.getElementById('tautulli-url').value,
                    api_key: document.getElementById('tautulli-api').value
                }
            },
            ripping: {
                min_length: parseInt(document.getElementById('min-length').value),
                main_feature_only: document.getElementById('main-feature-only').checked,
                skip_transcode: document.getElementById('skip-transcode').checked,
                auto_scan_on_insert: document.getElementById('auto-scan-on-insert').checked,
                auto_rip: document.getElementById('auto-rip').checked,
                auto_rip_delay: parseInt(document.getElementById('auto-rip-delay').value),
                confidence_threshold: parseInt(document.getElementById('confidence-threshold').value),
                notify_uncertain: document.getElementById('notify-uncertain').checked
            },
            paths: {
                raw_rips: document.getElementById('path-raw').value,
                movies: document.getElementById('path-movies').value,
                tv: document.getElementById('path-tv').value
            },
            notifications: {
                email: {
                    on_complete: document.getElementById('notify-complete').checked,
                    on_error: document.getElementById('notify-error').checked,
                    weekly_recap: document.getElementById('notify-weekly').checked,
                    recipients: getSelectedRecipients()
                }
            }
        };

        fetch('/api/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings)
        })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                alert('Settings saved!');
            }
        })
        .catch(err => {
            alert('Error saving settings');
        });
    });
</script>
{% endblock %}
