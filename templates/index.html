{% extends "base.html" %}

{% block title %}RipForge - Dashboard{% endblock %}
{% block page_title %}Dashboard{% endblock %}

{% block content %}
<div class="dashboard">
    <!-- Current Rip Status -->
    <section class="card rip-status">
        <h2>Current Status</h2>

        <!-- Idle State -->
        <div class="status-idle" id="status-idle">
            <div class="status-display">
                <div class="status-icon idle" id="status-icon">üìÄ</div>
                <div class="status-text">
                    <div class="status-title">Ready</div>
                    <div class="status-subtitle">Insert a disc to begin</div>
                </div>
            </div>

            <!-- Scan Results (hidden until scan completes) -->
            <div class="scan-results" id="scan-results" style="display: none;">
                <div class="scan-info">
                    <span class="scan-disc-type" id="scan-disc-type">DVD</span>
                    <span class="scan-media-type" id="scan-media-type" style="display: none;">TV</span>
                    <span class="scan-disc-label" id="scan-disc-label">DISC_LABEL</span>
                    <span class="scan-runtime" id="scan-runtime">1:30:00</span>
                    <span class="scan-size" id="scan-size"></span>
                </div>
                <div class="scan-title-edit">
                    <label for="custom-title">Title:</label>
                    <input type="text" id="custom-title" class="title-input" placeholder="Movie Title (Year)">
                    <span class="confidence-badge" id="confidence-badge" style="display: none;">HIGH</span>
                    <a href="#" id="imdb-search-btn" class="btn btn-small" target="_blank" title="Search IMDB">IMDB</a>
                </div>

                <!-- TV Season selector (shown for TV discs) -->
                <div class="tv-season-edit" id="tv-season-edit" style="display: none;">
                    <label for="season-number">Season:</label>
                    <input type="number" id="season-number" class="season-input" min="1" max="99" value="1">
                </div>

                <!-- TV Episode List (shown for TV discs) -->
                <div class="tv-episode-list" id="tv-episode-list" style="display: none;">
                    <div class="episode-list-header">
                        <span class="episode-list-title">Episodes to Rip</span>
                        <label class="select-all-label">
                            <input type="checkbox" id="select-all-episodes" checked> Select All
                        </label>
                    </div>
                    <div class="episode-items" id="episode-items">
                        <!-- Episode items will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Identification Methods Debug -->
                <div class="id-methods" id="id-methods" style="display: none;">
                    <div class="id-methods-header">
                        <span class="id-methods-toggle" onclick="toggleIdMethods()">Identification Details</span>
                    </div>
                    <div class="id-methods-list" id="id-methods-list"></div>
                </div>

                <!-- Auto-rip countdown -->
                <div class="auto-rip-countdown" id="auto-rip-countdown" style="display: none;">
                    <div class="countdown-ring">
                        <svg viewBox="0 0 100 100">
                            <circle class="countdown-bg" cx="50" cy="50" r="45"></circle>
                            <circle class="countdown-progress" cx="50" cy="50" r="45" id="countdown-circle"></circle>
                        </svg>
                        <span class="countdown-number" id="countdown-number">10</span>
                    </div>
                    <div class="countdown-text">
                        <span>Auto-rip in <strong id="countdown-seconds">10</strong>s</span>
                        <button class="btn btn-small btn-secondary" onclick="cancelCountdown()">Cancel</button>
                    </div>
                </div>
            </div>

            <div class="status-actions">
                <button class="btn btn-primary" id="btn-start-rip" onclick="startRip()">
                    Start Rip
                </button>
                <button class="btn btn-secondary" id="btn-scan-disc" onclick="scanDisc()">
                    Scan Disc
                </button>
                <button class="btn btn-danger" id="btn-reset-rip" onclick="resetRip()" style="display: none;" title="Clear current job state">
                    Reset
                </button>
                <button class="btn btn-secondary" id="btn-reset-drive" onclick="resetDriveState()" style="display: none;" title="Kill lingering MakeMKV processes and clear stale state. Use when scans fail after errors.">
                    Reset Drive
                </button>
                <button class="btn btn-secondary" id="btn-eject-disc" onclick="ejectDisc()" style="display: none;" title="Eject the disc from the drive">
                    Eject
                </button>
                <button class="btn btn-warning" id="btn-restart-service" onclick="restartService()" style="display: none;" title="Restart the RipForge service. Use as last resort if other options fail.">
                    Restart Service
                </button>
            </div>
        </div>

        <!-- Active Rip Checklist -->
        <div class="rip-checklist" id="rip-checklist" style="display: none;">
            <div class="rip-title" id="rip-title">
                <span class="disc-label">Processing disc...</span>
                <span class="current-step" id="current-step"></span>
            </div>

            <div class="checklist">
                <div class="checklist-item" id="step-insert" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Disc inserted</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-detect" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Detecting disc type</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-scan" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Scanning tracks</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-rip" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Ripping</span>
                    <span class="rip-substeps" id="rip-substeps"></span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-identify" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Identifying content</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-library" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Adding to library</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-move" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Moving to destination</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-scan-plex" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Triggering Plex scan</span>
                    <span class="check-detail"></span>
                </div>
            </div>

            <!-- Progress bar for current step -->
            <div class="rip-progress" id="rip-progress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="progress-info">
                    <span id="progress-text">0%</span>
                    <span id="progress-size"></span>
                    <span id="progress-eta"></span>
                </div>
            </div>

            <!-- Actions for rip in progress -->
            <div class="rip-actions" id="rip-actions" style="display: none; margin-top: 1rem; text-align: center;">
                <button class="btn btn-danger" id="btn-stop-rip" onclick="confirmStopDrive()">Stop Drive</button>
            </div>
        </div>
    </section>

    <!-- Hardware Flex Card -->
    <section class="card hardware-flex">
        <div class="hardware-header">
            <div class="ripforge-brand">
                <span class="brand-icon">üî•</span>
                <span class="brand-name">RipForge</span>
            </div>
            <span class="hardware-hostname" id="hw-hostname">-</span>
        </div>
        <div class="hardware-list" id="hardware-list">
            <div class="hw-row">
                <span class="hw-label">CPU</span>
                <span class="hw-value" id="hw-cpu">Detecting...</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">Memory</span>
                <span class="hw-value" id="hw-ram">-</span>
            </div>
            <div class="hw-row" id="hw-gpu-row" style="display: none;">
                <span class="hw-label">GPU</span>
                <span class="hw-value" id="hw-gpu">-</span>
            </div>
            <div id="hw-storage-rows">
                <!-- Storage rows will be inserted here dynamically -->
            </div>
            <div class="hw-row">
                <span class="hw-label">Optical Drive</span>
                <span class="hw-value" id="hw-optical">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">IP Address</span>
                <span class="hw-value" id="hw-ip">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">Uptime</span>
                <span class="hw-value" id="hw-uptime">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">OS</span>
                <span class="hw-value" id="hw-os">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">Docker</span>
                <span class="hw-value" id="hw-docker">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">RipForge <span class="version-dot" id="version-dot" title="Checking...">‚óè</span><span id="update-hint" class="update-hint"></span></span>
                <span class="hw-value">
                    <span id="version-number">v...</span>
                    <button id="btn-update" class="btn-update" style="display: none;" title="Install update">Update</button>
                </span>
            </div>
            <div class="hw-services">
                <div class="hw-services-header">Detected Services</div>
                <div class="hw-integrations">
                    <span class="int-item"><span class="int-dot" id="int-radarr">‚óè</span> Radarr</span>
                    <span class="int-item"><span class="int-dot" id="int-sonarr">‚óè</span> Sonarr</span>
                    <span class="int-item"><span class="int-dot" id="int-overseerr">‚óè</span> Overseerr</span>
                    <span class="int-item"><span class="int-dot" id="int-plex">‚óè</span> Plex</span>
                </div>
                <div class="ned-footer" id="ned-footer" style="display: none;">
                    Server monitored by <a href="https://getneddy.com" target="_blank" id="ned-link" class="ned-link">Ned</a>
                </div>
            </div>
        </div>
    </section>

    <!-- Needs Review Queue -->
    <section class="card review-queue" id="review-queue-section" style="display: none;">
        <div class="review-header">
            <h2>Needs Review</h2>
            <span class="review-count" id="review-count">0</span>
        </div>
        <p class="review-subtitle">These rips need manual identification before being added to your library.</p>
        <div class="review-items" id="review-items">
            <!-- Review items will be populated by JavaScript -->
        </div>
    </section>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirm-modal" style="display: none;">
        <div class="modal confirm-modal">
            <div class="modal-header">
                <h3 id="confirm-title">Confirm</h3>
            </div>
            <div class="modal-body">
                <p id="confirm-message">Are you sure?</p>
                <div class="confirm-actions">
                    <button class="btn btn-secondary" id="confirm-cancel">Cancel</button>
                    <button class="btn btn-danger" id="confirm-ok">Delete</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Review Modal -->
    <div class="modal-overlay" id="review-modal" style="display: none;">
        <div class="modal review-modal">
            <div class="modal-header">
                <h3>Identify This Rip</h3>
                <button class="modal-close" onclick="closeReviewModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="review-info">
                    <div class="review-detail">
                        <span class="label">Disc Label:</span>
                        <span class="value" id="modal-disc-label">-</span>
                    </div>
                    <div class="review-detail">
                        <span class="label">Runtime:</span>
                        <span class="value" id="modal-runtime">-</span>
                    </div>
                    <div class="review-detail">
                        <span class="label">Size:</span>
                        <span class="value" id="modal-size">-</span>
                    </div>
                    <div class="review-detail">
                        <span class="label">Type:</span>
                        <span class="value" id="modal-disc-type">-</span>
                    </div>
                </div>

                <div class="review-search">
                    <label for="review-search-input">Search for title:</label>
                    <div class="search-row">
                        <input type="text" id="review-search-input" placeholder="Movie or TV show name" autocomplete="off">
                        <button class="btn btn-primary" onclick="searchReviewTitle()">Search</button>
                    </div>
                    <small class="search-hint">Results from Radarr/TMDB. Click IMDB/TMDB links to verify. Wrong match? Try a different search.</small>
                </div>

                <div class="review-results" id="review-results" style="display: none;">
                    <div class="result-card" id="review-result-card">
                        <img class="result-poster" id="result-poster" src="" alt="Poster">
                        <div class="result-info">
                            <div class="result-title" id="result-title">-</div>
                            <div class="result-meta">
                                <span id="result-year">-</span> &bull;
                                <span id="result-runtime">-</span>
                            </div>
                            <div class="result-folder">
                                <span class="folder-label">Folder:</span>
                                <span id="result-folder-name">-</span>
                            </div>
                            <div class="result-links">
                                <a href="#" id="result-imdb-link" target="_blank" class="verify-link">IMDB</a>
                                <a href="#" id="result-tmdb-link" target="_blank" class="verify-link">TMDB</a>
                                <a href="#" id="result-tvdb-link" target="_blank" class="verify-link" style="display: none;">TVDB</a>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="review-actions">
                    <button class="btn btn-success" id="btn-apply-review" onclick="applyReviewIdentification()" disabled>Apply Identification</button>
                    <button class="btn btn-danger" onclick="deleteReviewItem()">Delete Rip</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Activity Log -->
    <section class="card activity-log full-width">
        <div class="log-header">
            <h2>Activity Log</h2>
            <div class="log-filters">
                <button class="log-filter active" data-filter="all">All</button>
                <button class="log-filter" data-filter="info">Info</button>
                <button class="log-filter" data-filter="error">Errors</button>
            </div>
        </div>
        <div class="log-container" id="log-container">
            <div class="log-entry info">
                <span class="log-time">--:--:--</span>
                <span class="log-level">INFO</span>
                <span class="log-message">Waiting for activity...</span>
            </div>
        </div>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Load status on page load
    document.addEventListener('DOMContentLoaded', function() {
        // First check rip status - if rip is active, that takes priority over scan results
        fetch('/api/rip/status')
            .then(r => r.json())
            .then(ripStatus => {
                if (ripStatus && ripStatus.status &&
                    !['idle', 'complete', 'error'].includes(ripStatus.status)) {
                    // Active rip in progress - show rip UI, don't restore scan results
                    showRipProgress(ripStatus);
                    discAlreadyProcessed = true;
                } else if (ripStatus && ripStatus.status === 'complete' || ripStatus.status === 'error') {
                    // Completed rip - show it
                    showRipProgress(ripStatus);
                } else {
                    // No active rip - restore scan results if any
                    restoreScanResults();
                }
            })
            .catch(() => {
                // On error, try to restore scan results
                restoreScanResults();
            });

        loadStatus();
        loadHardware();
        loadActivityLog();
        loadReviewQueue();     // Load review queue
        startDiscPolling();    // Start polling for disc insertion
        // Refresh status every 2 seconds (faster for progress bar updates)
        setInterval(loadStatus, 2000);
        // Refresh activity log every 5 seconds
        setInterval(loadActivityLog, 5000);
        // Refresh review queue every 30 seconds
        setInterval(loadReviewQueue, 30000);

        // Setup log filter buttons
        document.querySelectorAll('.log-filter').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.log-filter').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                document.getElementById('log-container').setAttribute('data-filter', this.dataset.filter);
            });
        });
    });

    // Load activity log
    function loadActivityLog() {
        fetch('/api/activity-log')
            .then(r => r.json())
            .then(data => {
                const container = document.getElementById('log-container');
                if (!data.log || data.log.length === 0) {
                    container.innerHTML = `
                        <div class="log-entry info">
                            <span class="log-time">--:--:--</span>
                            <span class="log-level">INFO</span>
                            <span class="log-message">No activity logged yet</span>
                        </div>
                    `;
                    return;
                }

                let html = '';
                data.log.forEach(entry => {
                    // Parse log entry format: "YYYY-MM-DD HH:MM:SS | LEVEL | message"
                    // or fallback to simple text
                    let time = '--:--:--';
                    let level = 'info';
                    let message = entry;

                    const match = entry.match(/^(\d{4}-\d{2}-\d{2}\s+)?(\d{2}:\d{2}:\d{2})?\s*\|?\s*(INFO|ERROR|WARN|SUCCESS|DEBUG|START)?\s*\|?\s*(.*)$/i);
                    if (match) {
                        time = match[2] || '--:--:--';
                        level = (match[3] || 'info').toLowerCase();
                        message = match[4] || entry;
                    }

                    // Map log levels
                    if (level === 'warn') level = 'warning';

                    html += `
                        <div class="log-entry ${level}">
                            <span class="log-time">${time}</span>
                            <span class="log-level">${level.toUpperCase()}</span>
                            <span class="log-message">${escapeHtml(message)}</span>
                        </div>
                    `;
                });

                container.innerHTML = html;
            })
            .catch(err => {
                console.error('Error loading activity log:', err);
            });
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Restore scan results from sessionStorage (persists across tab switches)
    function restoreScanResults() {
        const saved = sessionStorage.getItem('scanResults');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                displayScanResults(data);
            } catch (e) {
                console.error('Error restoring scan results:', e);
            }
        }
    }

    // Save scan results to sessionStorage
    function saveScanResults(data) {
        sessionStorage.setItem('scanResults', JSON.stringify(data));
    }

    // Get saved scan results
    function getScanResults() {
        const saved = sessionStorage.getItem('scanResults');
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {
                return null;
            }
        }
        return null;
    }

    // Clear scan results
    function clearScanResults() {
        sessionStorage.removeItem('scanResults');
        document.getElementById('scan-results').style.display = 'none';
        document.getElementById('auto-rip-countdown').style.display = 'none';
        document.getElementById('btn-start-rip').textContent = 'Start Rip';
        showingScanResults = false;
        cancelCountdown();
    }

    // Display scan results in the UI
    function displayScanResults(data) {
        showingScanResults = true;

        // Store scan data for later use
        window.currentScanData = data;

        // Update status text
        const statusTitle = document.querySelector('.status-title');
        const statusSubtitle = document.querySelector('.status-subtitle');

        // Check if this is a TV disc
        const isTVDisc = data.media_type === 'tv' || data.is_tv_disc;

        if (data.identified) {
            statusTitle.textContent = data.identified.title;
            if (isTVDisc) {
                const seasonNum = data.season_number || 1;
                const epCount = data.episode_tracks ? data.episode_tracks.length : 0;
                statusSubtitle.textContent = `TV Show - Season ${seasonNum} (${epCount} episodes, ${data.identified.confidence}% confidence)`;
            } else {
                statusSubtitle.textContent = `Identified with ${data.identified.confidence}% confidence`;
            }
        } else {
            statusTitle.textContent = data.parsed_search || data.disc_label;
            if (isTVDisc) {
                statusSubtitle.textContent = 'TV Show detected - please verify series and season';
            } else {
                statusSubtitle.textContent = 'Could not auto-identify - please verify title';
            }
        }

        // Show scan results section
        const scanResults = document.getElementById('scan-results');
        scanResults.style.display = 'block';

        // Fill in disc info
        document.getElementById('scan-disc-type').textContent = (data.disc_type || 'DISC').toUpperCase();
        document.getElementById('scan-disc-label').textContent = data.disc_label;

        // Show media type badge for TV
        const mediaTypeBadge = document.getElementById('scan-media-type');
        if (isTVDisc) {
            mediaTypeBadge.textContent = 'TV';
            mediaTypeBadge.style.display = 'inline';
        } else {
            mediaTypeBadge.style.display = 'none';
        }

        // Runtime - show total for TV, main feature for movies
        if (isTVDisc && data.episode_tracks && data.episode_tracks.length > 0) {
            const totalDuration = data.episode_tracks.reduce((sum, t) => sum + t.duration, 0);
            const hours = Math.floor(totalDuration / 3600);
            const mins = Math.floor((totalDuration % 3600) / 60);
            document.getElementById('scan-runtime').textContent = hours > 0 ? `${hours}h ${mins}m total` : `${mins}m total`;
        } else if (data.main_feature !== null && data.tracks) {
            const track = data.tracks.find(t => t.index === data.main_feature);
            if (track) {
                document.getElementById('scan-runtime').textContent = track.duration_str;
            }
        }

        // Expected size
        if (data.expected_size_str) {
            document.getElementById('scan-size').textContent = data.expected_size_str;
        } else {
            document.getElementById('scan-size').textContent = '';
        }

        // Fill in editable title
        const titleInput = document.getElementById('custom-title');
        titleInput.value = data.suggested_title || data.parsed_search || data.disc_label;
        titleInput.placeholder = isTVDisc ? "Series Name" : "Movie Title (Year)";

        // Show TV-specific controls
        const tvSeasonEdit = document.getElementById('tv-season-edit');
        const tvEpisodeList = document.getElementById('tv-episode-list');

        if (isTVDisc) {
            // Show season editor
            tvSeasonEdit.style.display = 'flex';
            document.getElementById('season-number').value = data.season_number || 1;

            // Show episode list
            if (data.episode_tracks && data.episode_tracks.length > 0) {
                tvEpisodeList.style.display = 'block';
                populateEpisodeList(data.episode_tracks, data.episode_mapping || {});
            }
        } else {
            tvSeasonEdit.style.display = 'none';
            tvEpisodeList.style.display = 'none';
        }

        // Show confidence badge if identified
        const badge = document.getElementById('confidence-badge');
        if (data.identified && data.identified.confidence) {
            badge.style.display = 'inline';
            if (data.identified.confidence >= 75) {
                badge.textContent = 'HIGH';
                badge.className = 'confidence-badge high';
            } else if (data.identified.confidence >= 50) {
                badge.textContent = 'MEDIUM';
                badge.className = 'confidence-badge medium';
            } else {
                badge.textContent = 'LOW';
                badge.className = 'confidence-badge low';
            }
        } else {
            badge.style.display = 'none';
        }

        // Show identification methods debug info
        const methodsContainer = document.getElementById('id-methods');
        const methodsList = document.getElementById('id-methods-list');
        if (data.identification_methods && data.identification_methods.length > 0) {
            methodsContainer.style.display = 'block';
            let html = '';
            data.identification_methods.forEach(method => {
                const confClass = method.confidence >= 75 ? 'high' : (method.confidence >= 50 ? 'medium' : 'low');
                html += `
                    <div class="id-method">
                        <div class="id-method-header">
                            <span class="id-method-name">${method.method}</span>
                            <span class="id-method-conf ${confClass}">${method.confidence}%</span>
                        </div>
                        <div class="id-method-result">${method.result}</div>
                        <div class="id-method-details">${method.details}</div>
                    </div>
                `;
            });
            methodsList.innerHTML = html;
        } else {
            methodsContainer.style.display = 'none';
        }

        // Set IMDB search link - use TV search for TV discs
        const imdbBtn = document.getElementById('imdb-search-btn');
        const searchTerm = data.parsed_search || data.disc_label.replace(/_/g, ' ');
        if (isTVDisc) {
            imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(searchTerm)}&s=tt&ttype=tv`;
        } else {
            imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(searchTerm)}&s=tt&ttype=ft`;
        }

        // Update IMDB link and rip button when title input changes
        titleInput.addEventListener('input', function() {
            const term = this.value.trim() || searchTerm;
            if (isTVDisc) {
                imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(term)}&s=tt&ttype=tv`;
            } else {
                imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(term)}&s=tt&ttype=ft`;
            }
            // Update rip button to show what will be ripped
            updateRipButtonText(this.value.trim(), isTVDisc);
            // Cancel countdown if user is editing
            cancelCountdown();
        });

        // Set initial button text
        updateRipButtonText(titleInput.value.trim(), isTVDisc);

        // Only start auto-rip countdown if confident identification
        // If needs_review is true, wait for user to confirm
        if (data.needs_review) {
            // Show review needed banner
            if (isTVDisc) {
                statusSubtitle.textContent = '‚ö†Ô∏è Please verify series name and season before ripping';
            } else {
                statusSubtitle.textContent = '‚ö†Ô∏è Low confidence - please verify title before ripping';
            }
        } else {
            // Start auto-rip countdown
            startCountdown();
        }
    }

    // Populate the episode list for TV discs
    function populateEpisodeList(episodeTracks, episodeMapping) {
        const container = document.getElementById('episode-items');
        let html = '';

        episodeTracks.forEach((track, idx) => {
            const epInfo = episodeMapping[track.index] || {};
            const epNum = epInfo.episode_number || (idx + 1);
            const epTitle = epInfo.title || `Episode ${epNum}`;
            const duration = track.duration_str || formatDuration(track.duration);

            html += `
                <div class="episode-item" data-track="${track.index}">
                    <label class="episode-checkbox">
                        <input type="checkbox" class="ep-select" data-track="${track.index}" checked>
                    </label>
                    <span class="episode-number">E${epNum.toString().padStart(2, '0')}</span>
                    <span class="episode-title">${escapeHtml(epTitle)}</span>
                    <span class="episode-duration">${duration}</span>
                </div>
            `;
        });

        container.innerHTML = html;

        // Setup select-all checkbox
        document.getElementById('select-all-episodes').addEventListener('change', function() {
            document.querySelectorAll('.ep-select').forEach(cb => cb.checked = this.checked);
            updateRipButtonForTV();
        });

        // Update rip button when individual episodes are toggled
        document.querySelectorAll('.ep-select').forEach(cb => {
            cb.addEventListener('change', updateRipButtonForTV);
        });
    }

    function formatDuration(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function updateRipButtonForTV() {
        const selectedCount = document.querySelectorAll('.ep-select:checked').length;
        const totalCount = document.querySelectorAll('.ep-select').length;
        const titleInput = document.getElementById('custom-title');
        const title = titleInput.value.trim();

        if (selectedCount === 0) {
            document.getElementById('btn-start-rip').textContent = 'Select Episodes';
            document.getElementById('btn-start-rip').disabled = true;
        } else {
            document.getElementById('btn-start-rip').disabled = false;
            if (title) {
                document.getElementById('btn-start-rip').textContent = `Rip ${selectedCount} Episode${selectedCount > 1 ? 's' : ''}`;
            } else {
                document.getElementById('btn-start-rip').textContent = `Rip ${selectedCount} Episode${selectedCount > 1 ? 's' : ''}`;
            }
        }
    }

    // Get selected episode tracks for TV rip
    function getSelectedEpisodeTracks() {
        const selected = [];
        document.querySelectorAll('.ep-select:checked').forEach(cb => {
            selected.push(parseInt(cb.dataset.track));
        });
        return selected;
    }

    function loadHardware() {
        fetch('/api/hardware')
            .then(r => r.json())
            .then(data => {
                document.getElementById('hw-hostname').textContent = data.hostname || '-';

                // CPU - show cores on second line if present
                let cpuHtml = data.cpu;
                if (data.cpu_cores) {
                    cpuHtml += `<br><span class="hw-subtext">${data.cpu_cores} cores</span>`;
                }
                document.getElementById('hw-cpu').innerHTML = cpuHtml;

                // Memory - include type and speed if available
                let ramText = data.ram_used_gb + ' GB used / ' + data.ram_gb + ' GB';
                if (data.ram_type || data.ram_speed) {
                    let ramExtra = [];
                    if (data.ram_type) ramExtra.push(data.ram_type);
                    if (data.ram_speed) ramExtra.push(data.ram_speed);
                    ramText += `<br><span class="hw-subtext">${ramExtra.join(' ')}</span>`;
                }
                document.getElementById('hw-ram').innerHTML = ramText;

                document.getElementById('hw-os').textContent = data.os || '-';

                // IP Address - show interface type if available
                let ipText = data.ip_address || '-';
                if (data.network_interface) {
                    ipText += ` (${data.network_interface})`;
                }
                document.getElementById('hw-ip').textContent = ipText;

                document.getElementById('hw-uptime').textContent = data.uptime || '-';
                document.getElementById('hw-docker').textContent = data.docker_version || '-';

                // GPU - prefer discrete, fall back to integrated
                if (data.gpu) {
                    document.getElementById('hw-gpu').textContent = data.gpu;
                    document.getElementById('hw-gpu-row').style.display = 'flex';
                } else if (data.integrated_gpu) {
                    document.getElementById('hw-gpu').textContent = data.integrated_gpu + ' (integrated)';
                    document.getElementById('hw-gpu-row').style.display = 'flex';
                }

                // Storage drives (mounted)
                const storageContainer = document.getElementById('hw-storage-rows');
                storageContainer.innerHTML = '';
                if (data.storage && data.storage.length > 0) {
                    data.storage.forEach(drive => {
                        const row = document.createElement('div');
                        row.className = 'hw-row';
                        // Format: "media (HDD)" or "storage (SSD)"
                        let label = drive.mount.replace('/mnt/', '').replace('/media/', '');
                        if (drive.type) {
                            label += ` <span class="drive-type">${drive.type}</span>`;
                        }
                        // Fix df's 1% minimum - show 0% if used is tiny (KB range)
                        let percent = drive.percent;
                        if (drive.used.endsWith('K') && percent === '1%') {
                            percent = '0%';
                        }
                        row.innerHTML = `
                            <span class="hw-label">${label}</span>
                            <span class="hw-value">${drive.used} / ${drive.size} (${percent})</span>
                        `;
                        storageContainer.appendChild(row);
                    });
                } else if (data.disk_total) {
                    // Fallback to single media drive
                    const row = document.createElement('div');
                    row.className = 'hw-row';
                    row.innerHTML = `
                        <span class="hw-label">Media</span>
                        <span class="hw-value">${data.disk_used} / ${data.disk_total} (${data.disk_percent}%)</span>
                    `;
                    storageContainer.appendChild(row);
                }

                // Physical drives (show as expandable details)
                if (data.drives && data.drives.length > 0) {
                    const drivesRow = document.createElement('div');
                    drivesRow.className = 'hw-row hw-drives-toggle';
                    drivesRow.innerHTML = `
                        <span class="hw-label">Physical Drives <span class="toggle-arrow">‚ñ∏</span></span>
                        <span class="hw-value">${data.drives.length} drives</span>
                    `;
                    const drivesList = document.createElement('div');
                    drivesList.className = 'hw-drives-list';
                    drivesList.style.display = 'none';
                    data.drives.forEach(drive => {
                        const driveRow = document.createElement('div');
                        driveRow.className = 'hw-row hw-row-nested';
                        driveRow.innerHTML = `
                            <span class="hw-label">${drive.name.replace('/dev/', '')} <span class="drive-type">${drive.type}</span></span>
                            <span class="hw-value">${drive.size}<br><span class="hw-subtext">${drive.model}</span></span>
                        `;
                        drivesList.appendChild(driveRow);
                    });
                    storageContainer.appendChild(drivesRow);
                    storageContainer.appendChild(drivesList);

                    // Toggle click handler
                    drivesRow.onclick = () => {
                        const isHidden = drivesList.style.display === 'none';
                        drivesList.style.display = isHidden ? 'block' : 'none';
                        drivesRow.querySelector('.toggle-arrow').textContent = isHidden ? '‚ñæ' : '‚ñ∏';
                    };
                }

                // Optical drive
                if (data.optical_drives && data.optical_drives.length > 0) {
                    document.getElementById('hw-optical').textContent = data.optical_drives[0].model || data.optical_drives[0].device;
                }

                // Ned monitoring agent (cross-promotion)
                if (data.ned && data.ned.installed) {
                    document.getElementById('ned-footer').style.display = 'block';
                    const nedLink = document.getElementById('ned-link');
                    if (data.ned.dashboard_url) {
                        nedLink.href = data.ned.dashboard_url;
                        nedLink.title = 'View server in Ned dashboard';
                    }
                }
            })
            .catch(err => console.error('Error loading hardware:', err));

        // Load version info (daily auto-check)
        const lastCheck = localStorage.getItem('ripforge_last_update_check');
        const cachedUpdate = localStorage.getItem('ripforge_update_available');
        const cachedLatest = localStorage.getItem('ripforge_latest_version');
        const oneDayMs = 24 * 60 * 60 * 1000;
        const shouldCheck = !lastCheck || (Date.now() - new Date(lastCheck).getTime()) > oneDayMs;

        function updateVersionUI(data) {
            const versionEl = document.getElementById('version-number');
            const dotEl = document.getElementById('version-dot');
            const updateBtn = document.getElementById('btn-update');
            const updateHint = document.getElementById('update-hint');
            versionEl.textContent = 'v' + data.current_version;

            if (data.error) {
                dotEl.className = 'version-dot unknown';
                dotEl.title = 'Unable to check for updates';
                updateBtn.style.display = 'none';
                updateHint.textContent = '';
            } else if (data.update_available) {
                dotEl.className = 'version-dot update-available';
                dotEl.title = 'Update available: v' + data.latest_version;
                updateBtn.style.display = 'inline-block';
                updateHint.textContent = 'v' + data.latest_version + ' available';
            } else {
                dotEl.className = 'version-dot up-to-date';
                dotEl.title = 'Up to date';
                updateBtn.style.display = 'none';
                updateHint.textContent = '';
            }
        }

        if (shouldCheck) {
            fetch('/api/version')
                .then(r => r.json())
                .then(data => {
                    localStorage.setItem('ripforge_last_update_check', new Date().toISOString());
                    localStorage.setItem('ripforge_update_available', data.update_available ? 'true' : 'false');
                    localStorage.setItem('ripforge_latest_version', data.latest_version || '');
                    updateVersionUI(data);
                })
                .catch(err => console.error('Error loading version:', err));
        } else {
            // Use cached status, but verify it's still valid
            fetch('/api/version')
                .then(r => r.json())
                .then(data => {
                    // Only show update if cached latest is actually newer than current
                    if (cachedUpdate === 'true' && cachedLatest && cachedLatest !== data.current_version) {
                        data.update_available = true;
                        data.latest_version = cachedLatest;
                    } else {
                        data.update_available = false;
                    }
                    updateVersionUI(data);
                })
                .catch(err => console.error('Error loading version:', err));
        }
    }

    function performUpdate() {
        const updateBtn = document.getElementById('btn-update');
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';

        fetch('/api/update', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    showToast('Update installed!', 'success');
                    countdownReload(updateBtn, 5);
                } else {
                    showToast('Update failed: ' + (data.error || 'Unknown error'), 'error');
                    updateBtn.disabled = false;
                    updateBtn.textContent = 'Update';
                }
            })
            .catch(err => {
                // Connection lost likely means service restarted
                countdownReload(updateBtn, 5);
            });
    }

    function countdownReload(btn, seconds) {
        let remaining = seconds;
        btn.textContent = `Restarting ${remaining}...`;
        const interval = setInterval(() => {
            remaining--;
            if (remaining > 0) {
                btn.textContent = `Restarting ${remaining}...`;
            } else {
                clearInterval(interval);
                btn.textContent = 'Reloading...';
                window.location.reload();
            }
        }, 1000);
    }

    document.getElementById('btn-update').addEventListener('click', performUpdate);

    function loadStatus() {
        fetch('/api/status')
            .then(r => r.json())
            .then(data => {
                // Update integration status (sidebar dots)
                for (const [service, status] of Object.entries(data.integrations)) {
                    const el = document.getElementById('int-' + service);
                    if (el) {
                        if (!status.enabled) {
                            el.className = 'int-dot disabled';
                        } else if (status.connected) {
                            el.className = 'int-dot connected';
                        } else {
                            el.className = 'int-dot error';
                        }
                    }
                }

                // Live RAM update
                if (data.ram) {
                    const ramEl = document.getElementById('hw-ram');
                    if (ramEl) {
                        // Preserve the existing subtext (type/speed) if present
                        const existingHtml = ramEl.innerHTML;
                        const subtextMatch = existingHtml.match(/<br><span class="hw-subtext">([^<]+)<\/span>/);
                        let ramHtml = data.ram.used_gb + ' GB used / ' + data.ram.total_gb + ' GB';
                        if (subtextMatch) {
                            ramHtml += '<br><span class="hw-subtext">' + subtextMatch[1] + '</span>';
                        }
                        ramEl.innerHTML = ramHtml;
                    }
                }

                // Update rip status
                if (data.ripping) {
                    showRipProgress(data.ripping);
                } else {
                    showIdleState();
                }
            })
            .catch(err => console.error('Error loading status:', err));
    }

    // Update rip button to show the title that will be used
    function updateRipButtonText(title, isTVDisc = false) {
        const btn = document.getElementById('btn-start-rip');
        if (isTVDisc) {
            // For TV, call the TV-specific update function
            updateRipButtonForTV();
        } else if (title) {
            // Truncate long titles
            const displayTitle = title.length > 30 ? title.substring(0, 27) + '...' : title;
            btn.textContent = `Rip "${displayTitle}"`;
            btn.disabled = false;
        } else {
            btn.textContent = 'Start Rip';
            btn.disabled = false;
        }
    }

    // Checklist UI Functions
    // Track if we're showing scan results (don't overwrite with idle)
    let showingScanResults = false;
    // Track if scan is in progress (don't let polling reset UI)
    let scanInProgress = false;
    // Auto-rip countdown
    let countdownInterval = null;
    let countdownSeconds = 20;
    const AUTO_RIP_ENABLED = {{ config.get('ripping', {}).get('auto_rip', true) | tojson }};
    const AUTO_RIP_DELAY = {{ config.get('ripping', {}).get('auto_rip_delay', 20) }};
    const AUTO_SCAN_ON_INSERT = {{ config.get('ripping', {}).get('auto_scan_on_insert', true) | tojson }};
    const HANDS_FREE = {{ config.get('ripping', {}).get('hands_free', false) | tojson }};

    // Disc insert polling
    let lastDiscState = false;
    let discPollInterval = null;
    let discAlreadyProcessed = false;  // Track if current disc was already scanned/ripped
    let processedDiscLabel = sessionStorage.getItem('processedDiscLabel') || null;  // Persist across refresh

    function startDiscPolling() {
        if (!AUTO_SCAN_ON_INSERT) return;

        discPollInterval = setInterval(() => {
            // Don't poll if scan is in progress
            if (scanInProgress) return;

            // If disc already processed and still present, only do lightweight status check
            // Don't hit the drive with blkid repeatedly
            if (discAlreadyProcessed && lastDiscState) {
                // Just check rip status, don't hit the drive
                fetch('/api/rip/status')
                    .then(r => r.json())
                    .then(ripStatus => {
                        // If rip just completed, we still have disc - wait for eject
                        // Only do a disc check occasionally (every 10 seconds via counter)
                    })
                    .catch(() => {});
                return;
            }

            // First check if a rip is already running
            fetch('/api/rip/status')
                .then(r => r.json())
                .then(ripStatus => {
                    // If rip is active, mark disc as processed and don't scan
                    if (ripStatus && ripStatus.status &&
                        !['idle', 'complete', 'error'].includes(ripStatus.status)) {
                        discAlreadyProcessed = true;
                        return null; // Skip disc check
                    }
                    return fetch('/api/disc/check').then(r => r.json());
                })
                .then(data => {
                    if (!data) return; // Skipped because rip is running

                    const discPresent = data.present;

                    // Disc was ejected - reset everything for the next disc
                    if (!discPresent && lastDiscState) {
                        console.log('Disc ejected, resetting for new disc');
                        discAlreadyProcessed = false;
                        processedDiscLabel = null;
                        sessionStorage.removeItem('processedDiscLabel');
                        showingScanResults = false;
                        clearScanResults();
                        // Also reset the backend job so UI goes back to ready state
                        fetch('/api/rip/reset', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        }).then(() => {
                            // Reset UI to idle state
                            document.getElementById('rip-checklist').style.display = 'none';
                            document.getElementById('status-idle').style.display = 'block';
                            document.querySelector('.status-title').textContent = 'Ready';
                            document.querySelector('.status-subtitle').textContent = 'Insert a disc to begin';
                        }).catch(() => {});
                    }

                    // Detect disc insertion (was not present, now present, not already processed)
                    if (discPresent && !lastDiscState && !discAlreadyProcessed) {
                        // Check if this disc was already processed (survives page refresh)
                        if (data.label && data.label === processedDiscLabel) {
                            console.log('Disc already processed (from sessionStorage), skipping scan');
                            discAlreadyProcessed = true;
                        } else if (HANDS_FREE) {
                            // Hands-free mode: skip scan, start rip immediately
                            console.log('Disc inserted, hands-free mode - starting rip immediately...');
                            discAlreadyProcessed = true;
                            startHandsFreeRip(data.label);
                        } else {
                            console.log('Disc inserted, auto-scanning...');
                            discAlreadyProcessed = true;
                            scanDisc();
                        }
                    }

                    lastDiscState = discPresent;
                })
                .catch(() => {});
        }, 3000); // Poll every 3 seconds (reduced from 2)
    }

    function stopDiscPolling() {
        if (discPollInterval) {
            clearInterval(discPollInterval);
            discPollInterval = null;
        }
    }

    function startCountdown() {
        if (!AUTO_RIP_ENABLED) return;

        countdownSeconds = AUTO_RIP_DELAY;
        const countdownEl = document.getElementById('auto-rip-countdown');
        const numberEl = document.getElementById('countdown-number');
        const secondsEl = document.getElementById('countdown-seconds');
        const circleEl = document.getElementById('countdown-circle');

        // Show countdown
        countdownEl.style.display = 'flex';

        // Calculate circle circumference (2 * PI * r)
        const circumference = 2 * Math.PI * 45;
        circleEl.style.strokeDasharray = circumference;

        function updateCountdown() {
            numberEl.textContent = countdownSeconds;
            secondsEl.textContent = countdownSeconds;

            // Update ring progress
            const progress = countdownSeconds / AUTO_RIP_DELAY;
            const offset = circumference * (1 - progress);
            circleEl.style.strokeDashoffset = offset;

            if (countdownSeconds <= 0) {
                cancelCountdown();
                startRip();
            } else {
                countdownSeconds--;
            }
        }

        updateCountdown();
        countdownInterval = setInterval(updateCountdown, 1000);
    }

    function cancelCountdown() {
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }
        document.getElementById('auto-rip-countdown').style.display = 'none';
    }

    function showIdleState() {
        document.getElementById('status-idle').style.display = 'block';
        document.getElementById('rip-checklist').style.display = 'none';

        // Only reset to "Ready" if not showing scan results and not scanning
        if (!showingScanResults && !scanInProgress) {
            document.querySelector('.status-title').textContent = 'Ready';
            document.querySelector('.status-subtitle').textContent = 'Insert a disc to begin';
        }
    }

    function showRipProgress(ripData) {
        document.getElementById('status-idle').style.display = 'none';
        document.getElementById('rip-checklist').style.display = 'block';

        // Update title - handle TV shows with season info
        let displayTitle = ripData.identified_title || ripData.disc_label || 'Processing disc...';
        if (ripData.media_type === 'tv' && ripData.season_number) {
            displayTitle = `${ripData.series_title || ripData.identified_title} S${ripData.season_number.toString().padStart(2, '0')}`;
        }
        document.querySelector('.disc-label').textContent = displayTitle;

        // Update each step and find current active step
        const steps = ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'];
        const stepNames = {
            'insert': 'Inserting',
            'detect': 'Detecting',
            'scan': 'Scanning',
            'rip': 'Ripping',
            'identify': 'Identifying',
            'library': 'Library',
            'move': 'Moving',
            'scan-plex': 'Plex Scan'
        };
        let currentStepName = '';
        steps.forEach(step => {
            const stepData = ripData.steps ? ripData.steps[step] : null;
            if (stepData) {
                updateStep('step-' + step, stepData.status, stepData.detail);
                if (stepData.status === 'active') {
                    currentStepName = stepNames[step] || step;
                }
            }
        });

        // Update rip substeps for compact single-line display
        updateRipSubsteps(ripData);

        // Show current step or completion status
        const currentStepEl = document.getElementById('current-step');
        if (ripData.status === 'complete') {
            currentStepEl.textContent = 'Complete';
            currentStepEl.className = 'current-step complete';
            // Save disc label to prevent re-scan on page refresh
            if (ripData.disc_label) {
                processedDiscLabel = ripData.disc_label;
                sessionStorage.setItem('processedDiscLabel', ripData.disc_label);
            }
        } else if (ripData.status === 'error') {
            currentStepEl.textContent = 'Error';
            currentStepEl.className = 'current-step error';
        } else if (currentStepName) {
            currentStepEl.textContent = currentStepName;
            currentStepEl.className = 'current-step active';
        } else {
            currentStepEl.textContent = '';
        }

        // Update progress bar if ripping (show when rip step is active or progress > 0)
        const ripStepActive = ripData.steps && ripData.steps.rip && ripData.steps.rip.status === 'active';
        if (ripStepActive || (ripData.progress !== undefined && ripData.progress > 0)) {
            document.getElementById('rip-progress').style.display = 'block';
            const pct = ripData.progress || 0;
            document.getElementById('progress-fill').style.width = pct + '%';
            document.getElementById('progress-text').textContent = pct + '%';

            // Show file size progress
            const sizeEl = document.getElementById('progress-size');
            if (ripData.current_size_bytes > 0 || ripData.expected_size_bytes > 0) {
                const currentGB = (ripData.current_size_bytes || 0) / (1024*1024*1024);
                const expectedGB = (ripData.expected_size_bytes || 0) / (1024*1024*1024);
                if (expectedGB > 0) {
                    sizeEl.textContent = `${currentGB.toFixed(1)} / ${Math.ceil(expectedGB * 10) / 10} GB`;
                } else {
                    sizeEl.textContent = `${currentGB.toFixed(1)} GB`;
                }
            } else {
                sizeEl.textContent = '';
            }

            // Show episode progress for TV
            const etaEl = document.getElementById('progress-eta');
            if (ripData.status === 'complete') {
                etaEl.textContent = 'Completed';
            } else if (ripData.media_type === 'tv' && ripData.total_tracks > 0) {
                const currentEp = (ripData.current_track_index || 0) + 1;
                etaEl.textContent = `Episode ${currentEp} of ${ripData.total_tracks}`;
            } else if (ripData.eta) {
                etaEl.textContent = ripData.eta;
            } else if (pct === 0) {
                etaEl.textContent = 'Starting...';
            } else if (pct >= 100) {
                etaEl.textContent = 'Finishing...';
            }
        } else {
            document.getElementById('rip-progress').style.display = 'none';
        }

        // Show stop button during rip, reset button on error/complete
        const resetBtn = document.getElementById('btn-reset-rip');
        const ripActions = document.getElementById('rip-actions');
        const stopBtn = document.getElementById('btn-stop-rip');
        if (ripData.status === 'error' || ripData.status === 'complete') {
            // Rip finished - show Reset, hide Stop Drive
            resetBtn.style.display = 'inline-block';
            // Show recovery buttons on error
            if (ripData.status === "error") {
                document.getElementById("btn-reset-drive").style.display = "inline-block";
                document.getElementById("btn-eject-disc").style.display = "inline-block";
                document.getElementById("btn-restart-service").style.display = "inline-block";
            } else {
                document.getElementById("btn-reset-drive").style.display = "none";
                document.getElementById("btn-restart-service").style.display = "none";
            }
            document.getElementById("btn-eject-disc").style.display = "inline-block";
            ripActions.style.display = 'none';
            stopBtn.style.display = 'none';
            document.getElementById('btn-start-rip').disabled = false;
            document.getElementById('btn-start-rip').textContent = 'Start Rip';
        } else if (ripData.status === 'ripping' || ripData.status === 'moving' || ripData.status === 'scanning') {
            // Rip in progress - show Stop Drive, hide Reset
            resetBtn.style.display = 'none';
            if (document.getElementById("btn-reset-drive")) document.getElementById("btn-reset-drive").style.display = "none";
            if (document.getElementById("btn-eject-disc")) document.getElementById("btn-eject-disc").style.display = "none";
            if (document.getElementById("btn-restart-service")) document.getElementById("btn-restart-service").style.display = "none";
            ripActions.style.display = 'block';
            stopBtn.style.display = 'inline-block';
        } else {
            resetBtn.style.display = 'none';
            if (document.getElementById("btn-reset-drive")) document.getElementById("btn-reset-drive").style.display = "none";
            if (document.getElementById("btn-eject-disc")) document.getElementById("btn-eject-disc").style.display = "none";
            if (document.getElementById("btn-restart-service")) document.getElementById("btn-restart-service").style.display = "none";
            ripActions.style.display = 'none';
            stopBtn.style.display = 'inline-block';
        }
    }

    function updateStep(stepId, status, detail) {
        const step = document.getElementById(stepId);
        if (!step) return;

        step.setAttribute('data-status', status);

        const icon = step.querySelector('.check-icon');
        const detailEl = step.querySelector('.check-detail');

        // Update icon based on status
        switch(status) {
            case 'pending':
                icon.textContent = '‚óã';
                break;
            case 'active':
                icon.textContent = '‚óê';
                break;
            case 'complete':
                icon.textContent = '‚úì';
                break;
            case 'error':
                icon.textContent = '‚úó';
                break;
        }

        // Update detail text (always set, even if empty, to clear old values)
        // But skip for rip step - we use substeps display instead
        if (stepId !== 'step-rip') {
            detailEl.textContent = detail || '';
        }
    }

    // Update rip substeps compact display
    function updateRipSubsteps(ripData) {
        const substepsEl = document.getElementById('rip-substeps');
        const ripStep = ripData.steps ? ripData.steps.rip : null;
        if (!substepsEl || !ripStep) {
            if (substepsEl) substepsEl.innerHTML = '';
            return;
        }

        // Only show substeps when rip step is active or has been active
        if (ripStep.status === 'pending') {
            substepsEl.innerHTML = '';
            return;
        }

        const mode = ripData.rip_mode || 'smart';
        const method = ripData.rip_method || 'direct';
        const directFailed = ripData.direct_failed || false;
        const progress = ripData.progress || 0;
        const detail = ripStep.detail || '';

        // Parse current phase from detail text
        const isBackingUp = detail.toLowerCase().includes('backup') && !detail.toLowerCase().includes('from backup');
        const isExtractingFromBackup = detail.toLowerCase().includes('from backup');
        const isDirect = !isBackingUp && !isExtractingFromBackup && method === 'direct';

        let html = '';

        if (mode === 'always_backup') {
            // Always backup: ‚óê Backup 6% ‚Üí ‚óã Extract
            if (isBackingUp) {
                html = `<span class="substep active">‚óê Backup ${progress}%</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep pending">‚óã Extract</span>`;
            } else if (isExtractingFromBackup) {
                html = `<span class="substep complete">‚úì Backup</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep active">‚óê Extract ${progress}%</span>`;
            } else if (ripStep.status === 'complete') {
                html = `<span class="substep complete">‚úì Backup</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep complete">‚úì Extract</span>`;
            } else if (ripStep.status === 'error') {
                html = `<span class="substep error">‚úó Failed</span>`;
            }
        } else if (mode === 'smart' && directFailed) {
            // Smart with fallback: ‚úó Direct ‚Üí ‚óê Backup 6% ‚Üí ‚óã Extract
            html = `<span class="substep error">‚úó Direct</span>`;
            html += `<span class="substep-arrow">‚Üí</span>`;
            if (isBackingUp) {
                html += `<span class="substep active">‚óê Backup ${progress}%</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep pending">‚óã Extract</span>`;
            } else if (isExtractingFromBackup) {
                html += `<span class="substep complete">‚úì Backup</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep active">‚óê Extract ${progress}%</span>`;
            } else if (ripStep.status === 'complete') {
                html += `<span class="substep complete">‚úì Backup</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep complete">‚úì Extract</span>`;
            } else if (ripStep.status === 'error') {
                html += `<span class="substep error">‚úó Backup failed</span>`;
            }
        } else {
            // Direct only or smart (direct working): ‚óê Direct 45%
            if (ripStep.status === 'active') {
                html = `<span class="substep active">‚óê Direct ${progress}%</span>`;
            } else if (ripStep.status === 'complete') {
                html = `<span class="substep complete">‚úì Direct</span>`;
            } else if (ripStep.status === 'error') {
                html = `<span class="substep error">‚úó Direct failed</span>`;
            }
        }

        substepsEl.innerHTML = html;
    }

    // Start a real rip
    function startRip() {
        const btn = document.getElementById('btn-start-rip');
        btn.disabled = true;
        btn.textContent = 'Starting...';

        // First check if a rip is already running - silently abort if so
        fetch('/api/rip/status')
            .then(r => r.json())
            .then(status => {
                if (status && status.status &&
                    !['idle', 'complete', 'error'].includes(status.status)) {
                    // Already ripping - just update UI to show progress, no error
                    console.log('Rip already in progress, showing status');
                    btn.disabled = false;
                    btn.textContent = 'Start Rip';
                    discAlreadyProcessed = true;
                    return null;
                }

                // Get custom title from input if scan was done
                const titleInput = document.getElementById('custom-title');
                const customTitle = titleInput && titleInput.value ? titleInput.value.trim() : null;

                // Get scan results to check if user corrected the title
                const scanData = getScanResults();

                // Check if this is a TV disc
                const isTVDisc = scanData && (scanData.media_type === 'tv' || scanData.is_tv_disc);

                // Clear scan results since we're starting the rip
                clearScanResults();

                // Build request with scan info for uncertain email logic
                const requestBody = {
                    device: '/dev/sr0',
                    custom_title: customTitle
                };

                // Include scan info so backend knows if title was corrected
                if (scanData) {
                    requestBody.original_suggested = scanData.suggested_title;
                    requestBody.was_uncertain = scanData.needs_review || false;
                    requestBody.disc_label = scanData.disc_label || '';
                    requestBody.runtime_str = scanData.runtime_str || '';
                    requestBody.confidence = scanData.identified ? scanData.identified.confidence : 0;
                }

                // Add TV-specific parameters
                if (isTVDisc) {
                    requestBody.media_type = 'tv';
                    requestBody.season_number = parseInt(document.getElementById('season-number').value) || 1;
                    requestBody.selected_tracks = getSelectedEpisodeTracks();
                    requestBody.episode_mapping = scanData.episode_mapping || {};
                    requestBody.series_title = customTitle || scanData.suggested_title || '';

                    // Validate that at least one episode is selected
                    if (requestBody.selected_tracks.length === 0) {
                        showToast('Please select at least one episode to rip', 'error');
                        btn.disabled = false;
                        btn.textContent = 'Select Episodes';
                        return null;
                    }
                } else {
                    requestBody.media_type = 'movie';
                }

                return fetch('/api/rip/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                }).then(r => r.json());
            })
            .then(data => {
                if (!data) return; // Already ripping, handled above
                if (data.success) {
                    // Rip started, status polling will update UI
                    discAlreadyProcessed = true;
                } else {
                    // Only show error if it's not "already ripping"
                    if (!data.error || !data.error.includes('Already')) {
                        showToast(data.error || 'Could not start rip', 'error');
                    }
                    btn.disabled = false;
                    btn.textContent = 'Start Rip';
                }
            })
            .catch(err => {
                showToast('Error starting rip', 'error');
                btn.disabled = false;
                btn.textContent = 'Start Rip';
            });
    }

    // Reset/cancel current rip
    function resetRip() {
        showingScanResults = false;  // Clear scan results flag
        fetch('/api/rip/reset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    // Reset UI
                    document.getElementById('btn-start-rip').disabled = false;
                    document.getElementById('btn-start-rip').textContent = 'Start Rip';
                    document.getElementById('btn-reset-rip').style.display = 'none';
                    document.getElementById('rip-actions').style.display = 'none';
                    document.getElementById('rip-checklist').style.display = 'none';
                    document.getElementById('rip-progress').style.display = 'none';
                    document.getElementById('status-idle').style.display = 'block';
                    // Reset all steps
                    ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'].forEach(step => {
                        updateStep(step, 'pending', '');
                    });
                }
            });
    }

    function resetDriveState() {
        showToast('Resetting drive state...', 'info');
        fetch('/api/drive/reset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    showToast('Drive reset complete. Disc present: ' + data.disc_present, 'success');
                    // Hide recovery buttons
                    document.getElementById('btn-reset-drive').style.display = 'none';
                    document.getElementById('btn-restart-service').style.display = 'none';
                } else {
                    showToast('Drive reset failed: ' + (data.error || 'Unknown error'), 'error');
                }
            })
            .catch(err => {
                showToast('Drive reset failed: ' + err, 'error');
            });
    }

    function ejectDisc() {
        fetch('/api/drive/eject', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    showToast('Disc ejected', 'success');
                } else {
                    showToast('Eject failed: ' + (data.error || 'Unknown error'), 'error');
                }
            })
            .catch(err => {
                showToast('Eject failed: ' + err, 'error');
            });
    }

    function restartService() {
        showConfirm(
            'This will restart the RipForge service. The page will reload automatically. Continue?',
            function() {
                showToast('Restarting service...', 'info');
                fetch('/api/service/restart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            showToast('Service restarting. Page will reload in 5 seconds...', 'success');
                            setTimeout(() => window.location.reload(), 5000);
                        } else {
                            showToast('Restart failed: ' + (data.error || 'Unknown error'), 'error');
                        }
                    })
                    .catch(err => {
                        // Service might have restarted, try reloading anyway
                        showToast('Reloading page...', 'info');
                        setTimeout(() => window.location.reload(), 3000);
                    });
            },
            'Restart Service',
            'Restart'
        );
    }


    function confirmStopDrive() {
        showConfirm(
            'This will stop any scanning or ripping in progress and eject the disc. Continue?',
            stopDrive,
            'Stop Drive',
            'Stop'
        );
    }

    function stopDrive() {
        const btn = document.getElementById('btn-stop-rip');
        btn.disabled = true;
        btn.textContent = 'Stopping...';

        fetch('/api/drive/stop', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    const msg = data.ejected ? 'Drive stopped and disc ejected' : 'Drive stopped';
                    showToast(msg, 'info');
                    // Reset UI
                    document.getElementById('btn-start-rip').disabled = false;
                    document.getElementById('btn-start-rip').textContent = 'Start Rip';
                    document.getElementById('rip-actions').style.display = 'none';
                    document.getElementById('rip-checklist').style.display = 'none';
                    document.getElementById('rip-progress').style.display = 'none';
                    document.getElementById('status-idle').style.display = 'block';
                    showingScanResults = false;
                    // Reset all steps
                    ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'].forEach(step => {
                        updateStep(step, 'pending', '');
                    });
                } else {
                    showToast('Failed to stop drive', 'error');
                }
            })
            .catch(err => {
                showToast('Error stopping drive', 'error');
            })
            .finally(() => {
                btn.disabled = false;
                btn.textContent = 'Stop Drive';
            });
    }

    // Scan disc info and identify
    function scanDisc() {
        const btn = document.getElementById('btn-scan-disc');
        btn.disabled = true;
        btn.textContent = 'Scanning...';
        scanInProgress = true;

        // Update status area to show scanning with spinner
        const statusTitle = document.querySelector('.status-title');
        const statusSubtitle = document.querySelector('.status-subtitle');
        const statusIcon = document.getElementById('status-icon');

        statusTitle.textContent = 'Scanning...';
        statusSubtitle.textContent = 'Reading disc and identifying content';
        statusIcon.classList.add('scanning');
        statusIcon.innerHTML = '<div class="scan-spinner"></div>';

        // Hide previous scan results while scanning
        document.getElementById('scan-results').style.display = 'none';

        fetch('/api/disc/scan-identify')
            .then(r => r.json())
            .then(data => {
                scanInProgress = false;
                if (data.error) {
                    // No disc or error
                    statusTitle.textContent = 'No Disc';
                    statusSubtitle.textContent = data.error || 'Insert a disc and try again';
                    clearScanResults();
                } else if (data.disc_label) {
                    // Found a disc - save and display results
                    saveScanResults(data);
                    displayScanResults(data);
                } else {
                    statusTitle.textContent = 'No Disc';
                    statusSubtitle.textContent = 'Insert a disc and try again';
                    clearScanResults();
                }
            })
            .catch(err => {
                scanInProgress = false;
                statusTitle.textContent = 'Scan Error';
                statusSubtitle.textContent = err.message || 'Could not read disc';
                clearScanResults();
            })
            .finally(() => {
                btn.disabled = false;
                btn.textContent = 'Scan Disc';
                // Reset icon
                statusIcon.classList.remove('scanning');
                statusIcon.innerHTML = 'üìÄ';
            });
    }

    // Hands-free mode: start rip with automatic TV detection
    function startHandsFreeRip(discLabel) {
        // Update UI to show we're starting
        const statusTitle = document.querySelector('.status-title');
        const statusSubtitle = document.querySelector('.status-subtitle');
        statusTitle.textContent = 'Detecting Disc...';
        statusSubtitle.textContent = discLabel || 'Getting disc info...';

        // First get disc info to detect if it's a TV disc
        fetch('/api/disc/info')
            .then(r => r.json())
            .then(info => {
                const isTVDisc = info.is_tv_disc || false;
                const episodeTracks = info.episode_tracks || [];

                // Build rip request
                const requestBody = {
                    device: '/dev/sr0',
                    custom_title: null,  // Let post-rip identification determine title
                    hands_free: true
                };

                if (isTVDisc && episodeTracks.length > 0) {
                    // TV disc - rip all episode tracks
                    requestBody.media_type = 'tv';
                    requestBody.season_number = 1;  // Default, will be corrected in post-ID
                    requestBody.selected_tracks = episodeTracks.map(t => t.index);
                    requestBody.series_title = info.disc_label || '';

                    statusTitle.textContent = 'Starting TV Rip...';
                    statusSubtitle.textContent = `${episodeTracks.length} episodes detected`;
                    console.log('Hands-free: TV disc detected, ripping', episodeTracks.length, 'episodes');
                } else {
                    // Movie disc - rip main feature
                    requestBody.media_type = 'movie';

                    statusTitle.textContent = 'Starting Rip...';
                    statusSubtitle.textContent = discLabel || 'Ripping main feature';
                    console.log('Hands-free: Movie disc, ripping main feature');
                }

                // Start the rip
                return fetch('/api/rip/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    console.log('Hands-free rip started');
                } else {
                    console.error('Error starting hands-free rip:', data.error);
                    statusTitle.textContent = 'Error';
                    statusSubtitle.textContent = data.error || 'Could not start rip';
                }
            })
            .catch(err => {
                console.error('Error starting hands-free rip:', err);
                statusTitle.textContent = 'Error';
                statusSubtitle.textContent = 'Could not start rip';
            });
    }

    // ========================
    // Review Queue Functions
    // ========================
    let currentReviewItem = null;
    let currentSearchResult = null;

    function loadReviewQueue() {
        fetch('/api/review/queue')
            .then(r => r.json())
            .then(data => {
                const section = document.getElementById('review-queue-section');
                const container = document.getElementById('review-items');
                const countEl = document.getElementById('review-count');

                if (data.items && data.items.length > 0) {
                    section.style.display = 'block';
                    countEl.textContent = data.items.length;

                    let html = '';
                    data.items.forEach(item => {
                        html += `
                            <div class="review-item" data-folder="${escapeHtml(item.folder_name)}">
                                <div class="review-item-info">
                                    <div class="review-item-title">${escapeHtml(item.fallback_title || item.disc_label)}</div>
                                    <div class="review-item-details">
                                        <span class="disc-type">${(item.disc_type || 'unknown').toUpperCase()}</span>
                                        <span class="runtime">${item.runtime_str || '-'}</span>
                                        <span class="size">${item.size_gb ? item.size_gb + ' GB' : ''}</span>
                                    </div>
                                </div>
                                <button class="btn btn-primary btn-small" onclick="openReviewModal('${escapeHtml(item.folder_name)}')">
                                    Identify
                                </button>
                            </div>
                        `;
                    });
                    container.innerHTML = html;

                    // Store items for modal access
                    window.reviewItems = data.items.reduce((acc, item) => {
                        acc[item.folder_name] = item;
                        return acc;
                    }, {});
                } else {
                    section.style.display = 'none';
                }
            })
            .catch(err => {
                console.error('Error loading review queue:', err);
            });
    }

    function openReviewModal(folderName) {
        const item = window.reviewItems[folderName];
        if (!item) return;

        currentReviewItem = item;
        currentSearchResult = null;

        // Populate modal with item details
        document.getElementById('modal-disc-label').textContent = item.disc_label || '-';
        document.getElementById('modal-runtime').textContent = item.runtime_str || '-';
        document.getElementById('modal-size').textContent = item.size_gb ? item.size_gb + ' GB' : '-';
        document.getElementById('modal-disc-type').textContent = (item.disc_type || 'unknown').toUpperCase();

        // Pre-fill search with fallback title
        document.getElementById('review-search-input').value = item.fallback_title || '';

        // Reset results
        document.getElementById('review-results').style.display = 'none';
        document.getElementById('btn-apply-review').disabled = true;

        // Show modal
        document.getElementById('review-modal').style.display = 'flex';
    }

    function closeReviewModal() {
        document.getElementById('review-modal').style.display = 'none';
        currentReviewItem = null;
        currentSearchResult = null;
    }

    function searchReviewTitle() {
        const query = document.getElementById('review-search-input').value.trim();
        if (!query || !currentReviewItem) return;

        const btn = event.target;
        btn.disabled = true;
        btn.textContent = 'Searching...';

        fetch('/api/review/search', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                query: query,
                runtime_seconds: currentReviewItem.runtime_seconds || 0,
                media_type: currentReviewItem.media_type || 'movie'
            })
        })
            .then(r => r.json())
            .then(data => {
                if (data.results && data.results.length > 0) {
                    const result = data.results[0];
                    currentSearchResult = result;

                    // Show result
                    document.getElementById('review-results').style.display = 'block';
                    document.getElementById('result-title').textContent = result.title || '-';
                    document.getElementById('result-year').textContent = result.year || '-';
                    document.getElementById('result-runtime').textContent = result.runtime_minutes ? result.runtime_minutes + ' min' : '-';
                    document.getElementById('result-folder-name').textContent = result.folder_name || '-';

                    if (result.poster_url) {
                        document.getElementById('result-poster').src = result.poster_url;
                        document.getElementById('result-poster').style.display = 'block';
                    } else {
                        document.getElementById('result-poster').style.display = 'none';
                    }

                    // Set verification links
                    const imdbLink = document.getElementById('result-imdb-link');
                    const tmdbLink = document.getElementById('result-tmdb-link');
                    const tvdbLink = document.getElementById('result-tvdb-link');

                    if (result.imdb_id) {
                        imdbLink.href = `https://www.imdb.com/title/${result.imdb_id}/`;
                        imdbLink.style.display = 'inline';
                    } else {
                        imdbLink.style.display = 'none';
                    }

                    if (result.tmdb_id) {
                        const tmdbType = result.media_type === 'tv' ? 'tv' : 'movie';
                        tmdbLink.href = `https://www.themoviedb.org/${tmdbType}/${result.tmdb_id}`;
                        tmdbLink.style.display = 'inline';
                    } else {
                        tmdbLink.style.display = 'none';
                    }

                    if (result.tvdb_id && result.media_type === 'tv') {
                        tvdbLink.href = `https://thetvdb.com/series/${result.tvdb_id}`;
                        tvdbLink.style.display = 'inline';
                    } else {
                        tvdbLink.style.display = 'none';
                    }

                    document.getElementById('btn-apply-review').disabled = false;
                } else {
                    document.getElementById('review-results').style.display = 'none';
                    document.getElementById('btn-apply-review').disabled = true;
                    showToast('No results found. Try a different search term.', 'info');
                }
            })
            .catch(err => {
                console.error('Search error:', err);
                showToast('Search failed. Please try again.', 'error');
            })
            .finally(() => {
                btn.disabled = false;
                btn.textContent = 'Search';
            });
    }

    function applyReviewIdentification() {
        if (!currentReviewItem || !currentSearchResult) return;

        const btn = document.getElementById('btn-apply-review');
        btn.disabled = true;
        btn.textContent = 'Applying...';

        fetch('/api/review/apply', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                folder_name: currentReviewItem.folder_name,
                identified_title: currentSearchResult.folder_name,
                media_type: currentSearchResult.media_type || 'movie',
                year: currentSearchResult.year || 0,
                tmdb_id: currentSearchResult.tmdb_id || 0,
                poster_url: currentSearchResult.poster_url || ''
            })
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    const folderName = currentSearchResult.folder_name;  // Save before closing modal
                    closeReviewModal();
                    loadReviewQueue();  // Refresh the queue
                    loadActivityLog();  // Refresh activity log
                    showToast(`Moved to library: ${folderName}`, 'success');
                } else {
                    showToast(data.error || 'Could not apply identification', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Apply Identification';
                }
            })
            .catch(err => {
                console.error('Apply error:', err);
                showToast('Error applying identification. Please try again.', 'error');
                btn.disabled = false;
                btn.textContent = 'Apply Identification';
            });
    }

    function deleteReviewItem() {
        if (!currentReviewItem) return;

        showConfirm(
            'Are you sure you want to delete this rip? This cannot be undone.',
            function() {
                fetch('/api/review/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder_name: currentReviewItem.folder_name
                    })
                })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            closeReviewModal();
                            loadReviewQueue();
                            loadActivityLog();
                            showToast('Deleted from review queue', 'info');
                        } else {
                            showToast(data.error || 'Could not delete item', 'error');
                        }
                    })
                    .catch(err => {
                        console.error('Delete error:', err);
                        showToast('Error deleting item. Please try again.', 'error');
                    });
            },
            'Delete Rip',
            'Delete'
        );
    }

    // Custom confirm modal
    let confirmCallback = null;

    function showConfirm(message, onConfirm, title = 'Confirm', okText = 'Delete') {
        document.getElementById('confirm-title').textContent = title;
        document.getElementById('confirm-message').textContent = message;
        document.getElementById('confirm-ok').textContent = okText;
        confirmCallback = onConfirm;
        document.getElementById('confirm-modal').style.display = 'flex';
    }

    function closeConfirm() {
        document.getElementById('confirm-modal').style.display = 'none';
        confirmCallback = null;
    }

    document.getElementById('confirm-cancel').addEventListener('click', closeConfirm);
    document.getElementById('confirm-ok').addEventListener('click', function() {
        if (confirmCallback) confirmCallback();
        closeConfirm();
    });

    // Close modals on escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            if (document.getElementById('review-modal').style.display === 'flex') {
                closeReviewModal();
            }
            if (document.getElementById('confirm-modal').style.display === 'flex') {
                closeConfirm();
            }
        }
    });

    // Close modals on overlay click
    document.getElementById('review-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeReviewModal();
        }
    });

    document.getElementById('confirm-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeConfirm();
        }
    });

    // Demo function to test the UI (can be called from console)
    function demoRip() {
        const steps = ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'];
        let currentStep = 0;

        document.getElementById('status-idle').style.display = 'none';
        document.getElementById('rip-checklist').style.display = 'block';
        document.querySelector('.disc-label').textContent = 'GUARDIANS_VOL_3';

        function advanceStep() {
            if (currentStep > 0) {
                updateStep('step-' + steps[currentStep - 1], 'complete', '');
            }
            if (currentStep < steps.length) {
                updateStep('step-' + steps[currentStep], 'active', 'Processing...');

                // Show progress bar during rip step
                if (steps[currentStep] === 'rip') {
                    document.getElementById('rip-progress').style.display = 'block';
                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress += 10;
                        document.getElementById('progress-fill').style.width = progress + '%';
                        document.getElementById('progress-text').textContent = progress + '%';
                        document.getElementById('progress-eta').textContent = (100 - progress) / 10 + ' min remaining';
                        if (progress >= 100) {
                            clearInterval(progressInterval);
                            document.getElementById('rip-progress').style.display = 'none';
                            currentStep++;
                            setTimeout(advanceStep, 500);
                        }
                    }, 300);
                    return;
                }

                currentStep++;
                setTimeout(advanceStep, 1000);
            } else {
                // All done
                setTimeout(() => {
                    showToast('Rip complete! Movie added to library.', 'success');
                    showIdleState();
                    // Reset all steps
                    steps.forEach(s => updateStep('step-' + s, 'pending', ''));
                }, 500);
            }
        }

        advanceStep();
    }
</script>
{% endblock %}
