{% extends "base.html" %}

{% block title %}RipForge - Dashboard{% endblock %}
{% block page_title %}Dashboard{% endblock %}

{% block content %}
<div class="dashboard">
    <!-- Current Rip Status -->
    <section class="card rip-status">
        <h2>Current Status</h2>
        <div class="auto-mode-status">
            <span class="auto-mode-item {% if config.ripping.auto_scan_on_insert != false %}active{% endif %}">
                Auto-scan: {% if config.ripping.auto_scan_on_insert != false %}ON{% else %}OFF{% endif %}
            </span>
            <span class="auto-mode-item {% if config.ripping.auto_rip != false %}active{% endif %}">
                Auto-rip: {% if config.ripping.auto_rip != false %}ON{% else %}OFF{% endif %}
            </span>
        </div>

        <!-- Idle State -->
        <div class="status-idle" id="status-idle">
            <div class="status-display">
                <div class="status-icon idle" id="status-icon">üìÄ</div>
                <div class="status-text">
                    <div class="status-title">Ready</div>
                    <div class="status-subtitle">Insert a disc to begin</div>
                </div>
            </div>

            <!-- Scan Results (hidden until scan completes) -->
            <div class="scan-results" id="scan-results" style="display: none;">
                <div class="scan-info">
                    <span class="scan-disc-type" id="scan-disc-type">DVD</span>
                    <div class="media-type-switch" onclick="toggleMediaType()" title="Click to toggle Movie/TV">
                        <span class="switch-option" id="switch-movie">MOVIE</span>
                        <span class="switch-option" id="switch-tv">TV</span>
                        <span class="switch-slider" id="switch-slider"></span>
                    </div>
                    <span class="scan-disc-label" id="scan-disc-label">DISC_LABEL</span>
                    <span class="scan-runtime" id="scan-runtime">1:30:00</span>
                    <span class="scan-size" id="scan-size"></span>
                </div>
                <div class="scan-title-edit">
                    <label for="custom-title">Title:</label>
                    <input type="text" id="custom-title" class="title-input" placeholder="Movie Title (Year)">
                    <span class="confidence-badge" id="confidence-badge" style="display: none;">HIGH</span>
                    <a href="#" id="imdb-search-btn" class="btn btn-small" target="_blank" title="Search IMDB">IMDB ‚Üó</a>
                </div>

                <!-- TV Season selector (shown for TV discs) -->
                <div class="tv-season-edit" id="tv-season-edit" style="display: none;">
                    <label for="season-number">Season:</label>
                    <input type="number" id="season-number" class="season-input" min="1" max="99" value="1">
                </div>

                <!-- TV Episode List (shown for TV discs) -->
                <div class="tv-episode-list" id="tv-episode-list" style="display: none;">
                    <div class="episode-list-header">
                        <span class="episode-list-title">Episodes to Rip</span>
                        <label class="select-all-label">
                            <input type="checkbox" id="select-all-episodes" checked> Select All
                        </label>
                    </div>
                    <div class="episode-items" id="episode-items">
                        <!-- Episode items will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Identification Methods Debug -->
                <div class="id-methods" id="id-methods" style="display: none;">
                    <div class="id-methods-header">
                        <span class="id-methods-toggle" onclick="toggleIdMethods()">Identification Details</span>
                    </div>
                    <div class="id-methods-list" id="id-methods-list"></div>
                </div>

                <!-- Auto-rip countdown -->
                <div class="auto-rip-countdown" id="auto-rip-countdown" style="display: none;">
                    <div class="countdown-ring">
                        <svg viewBox="0 0 100 100">
                            <circle class="countdown-bg" cx="50" cy="50" r="45"></circle>
                            <circle class="countdown-progress" cx="50" cy="50" r="45" id="countdown-circle"></circle>
                        </svg>
                        <span class="countdown-number" id="countdown-number">10</span>
                    </div>
                    <div class="countdown-text">
                        <span>Auto-rip in <strong id="countdown-seconds">10</strong>s</span>
                        <button class="btn btn-small btn-secondary" onclick="cancelCountdown()">Cancel</button>
                    </div>
                </div>
            </div>

            <div class="status-actions">
                <button class="btn btn-primary" id="btn-start-rip" onclick="startRip()">
                    Start Rip
                </button>
                <button class="btn btn-secondary" id="btn-scan-disc" onclick="scanDisc()">
                    Scan Disc
                </button>
                <button class="btn btn-danger" id="btn-stop" onclick="confirmStopDrive()" style="display: none;" title="Stop current operation">
                    Stop
                </button>
                <button class="btn btn-secondary" id="btn-eject" onclick="ejectDisc()" disabled title="Eject the disc from the drive">
                    Eject
                </button>
                <button class="btn btn-danger" id="btn-reset-rip" onclick="resetRip()" style="display: none;" title="Clear current job state">
                    Reset
                </button>
                <button class="btn btn-secondary" id="btn-reset-drive" onclick="resetDriveState()" style="display: none;" title="Kill lingering MakeMKV processes and clear stale state. Use when scans fail after errors.">
                    Reset Drive
                </button>
                <button class="btn btn-warning" id="btn-restart-service" onclick="restartService()" style="display: none;" title="Restart the RipForge service. Use as last resort if other options fail.">
                    Restart Service
                </button>
            </div>
        </div>

        <!-- Active Rip Checklist -->
        <div class="rip-checklist" id="rip-checklist" style="display: none;">
            <div class="rip-title" id="rip-title">
                <span class="disc-label">Processing disc...</span>
                <span class="disc-type-badge" id="rip-disc-type"></span>
                <span class="media-type-badge" id="rip-media-type"></span>
                <span class="current-step" id="current-step"></span>
            </div>

            <div class="checklist">
                <div class="checklist-item" id="step-insert" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Disc inserted</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-detect" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Detecting disc type</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-scan" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Scanning tracks</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-rip" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Ripping</span>
                    <span class="rip-substeps" id="rip-substeps"></span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-identify" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Identifying content</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-library" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Adding to library</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-move" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Moving to destination</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-scan-plex" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Triggering Plex scan</span>
                    <span class="check-detail"></span>
                </div>
            </div>

            <!-- Progress bar for current step -->
            <div class="rip-progress" id="rip-progress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="progress-info">
                    <span id="progress-text">0%</span>
                    <span id="progress-size"></span>
                    <span id="progress-eta"></span>
                </div>
            </div>

            <!-- Post-rip actions (shown on complete/error) -->
            <div class="post-rip-actions" id="post-rip-actions" style="display: none; margin-top: 1rem; text-align: center;">
                <button class="btn btn-danger" onclick="resetRip()">Reset</button>
            </div>
        </div>
    </section>

    <!-- Hardware Flex Card -->
    <section class="card hardware-flex">
        <div class="hardware-header">
            <div class="ripforge-brand">
                <span class="brand-icon">üî•</span>
                <span class="brand-name">RipForge</span>
            </div>
            <span class="hardware-hostname" id="hw-hostname">-</span>
        </div>
        <div class="hardware-list" id="hardware-list">
            <div class="hw-row">
                <span class="hw-label">CPU</span>
                <span class="hw-value" id="hw-cpu">Detecting...</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">Memory</span>
                <span class="hw-value" id="hw-ram">-</span>
            </div>
            <div class="hw-row" id="hw-gpu-row" style="display: none;">
                <span class="hw-label">GPU</span>
                <span class="hw-value" id="hw-gpu">-</span>
            </div>
            <div id="hw-storage-rows">
                <!-- Storage rows will be inserted here dynamically -->
            </div>
            <div class="hw-row">
                <span class="hw-label">Optical Drive</span>
                <span class="hw-value" id="hw-optical">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">IP Address</span>
                <span class="hw-value" id="hw-ip">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">Uptime</span>
                <span class="hw-value" id="hw-uptime">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">OS</span>
                <span class="hw-value" id="hw-os">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">Docker</span>
                <span class="hw-value" id="hw-docker">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">RipForge <span class="version-dot" id="version-dot" title="Checking...">‚óè</span><span id="update-hint" class="update-hint"></span></span>
                <span class="hw-value">
                    <span id="version-number">v...</span>
                    <button id="btn-update" class="btn-update" style="display: none;" title="Install update">Update</button>
                </span>
            </div>
            <div class="hw-services">
                <div class="hw-services-header">Detected Services</div>
                <div class="hw-integrations">
                    <span class="int-item"><span class="int-dot" id="int-radarr">‚óè</span> Radarr</span>
                    <span class="int-item"><span class="int-dot" id="int-sonarr">‚óè</span> Sonarr</span>
                    <span class="int-item"><span class="int-dot" id="int-overseerr">‚óè</span> Overseerr</span>
                    <span class="int-item"><span class="int-dot" id="int-plex">‚óè</span> Plex</span>
                </div>
                <div class="ned-footer" id="ned-footer" style="display: none;">
                    Server monitored by <a href="https://getneddy.com" target="_blank" id="ned-link" class="ned-link">Ned</a>
                </div>
            </div>
        </div>
    </section>

    <!-- Needs Review Queue -->
    <section class="card review-queue" id="review-queue-section" style="display: none;">
        <div class="review-header">
            <h2>Needs Review</h2>
            <span class="review-count" id="review-count">0</span>
        </div>
        <p class="review-subtitle">These rips need manual identification before being added to your library.</p>
        <div class="review-items" id="review-items">
            <!-- Review items will be populated by JavaScript -->
        </div>
    </section>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirm-modal" style="display: none;">
        <div class="modal confirm-modal">
            <div class="modal-header">
                <h3 id="confirm-title">Confirm</h3>
            </div>
            <div class="modal-body">
                <p id="confirm-message">Are you sure?</p>
                <div class="confirm-actions">
                    <button class="btn btn-secondary" id="confirm-cancel">Cancel</button>
                    <button class="btn btn-danger" id="confirm-ok">Delete</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Review Modal -->
    <div class="modal-overlay" id="review-modal" style="display: none;">
        <div class="modal review-modal">
            <div class="modal-header">
                <h3>Identify This Rip</h3>
                <button class="modal-close" onclick="closeReviewModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="review-info">
                    <div class="review-detail">
                        <span class="label">Disc Label:</span>
                        <span class="value" id="modal-disc-label">-</span>
                    </div>
                    <div class="review-detail">
                        <span class="label">Runtime:</span>
                        <span class="value" id="modal-runtime">-</span>
                    </div>
                    <div class="review-detail">
                        <span class="label">Size:</span>
                        <span class="value" id="modal-size">-</span>
                    </div>
                    <div class="review-detail">
                        <span class="label">Type:</span>
                        <span class="value" id="modal-disc-type">-</span>
                    </div>
                </div>

                <!-- Duplicate Comparison (shown only for duplicates) -->
                <div class="duplicate-comparison" id="duplicate-comparison" style="display: none;">
                    <div class="duplicate-header">
                        <span class="duplicate-warning">‚ö† Possible Duplicate Detected</span>
                    </div>
                    <div class="duplicate-grid">
                        <div class="duplicate-col">
                            <h4>Existing in Library</h4>
                            <div class="dup-detail"><span>Title:</span> <span id="dup-existing-title">-</span></div>
                            <div class="dup-detail"><span>Year:</span> <span id="dup-existing-year">-</span></div>
                            <div class="dup-detail"><span>Type:</span> <span id="dup-existing-type">-</span></div>
                            <div class="dup-detail"><span>Size:</span> <span id="dup-existing-size">-</span></div>
                            <div class="dup-detail"><span>Ripped:</span> <span id="dup-existing-date">-</span></div>
                            <button class="btn btn-secondary dup-col-btn" onclick="keepExistingRip()">Keep Existing</button>
                        </div>
                        <div class="duplicate-col">
                            <h4>New Rip</h4>
                            <div class="dup-detail"><span>Title:</span> <span id="dup-new-title">-</span></div>
                            <div class="dup-detail"><span>Year:</span> <span id="dup-new-year">-</span></div>
                            <div class="dup-detail"><span>Type:</span> <span id="dup-new-type">-</span></div>
                            <div class="dup-detail"><span>Size:</span> <span id="dup-new-size">-</span></div>
                            <div class="dup-detail"><span>Disc:</span> <span id="dup-new-disc">-</span></div>
                            <button class="btn btn-success dup-col-btn" onclick="keepNewRip()">Keep New (Replace)</button>
                        </div>
                    </div>
                    <div class="duplicate-actions">
                        <button class="btn btn-warning" onclick="keepBothRips()">Keep Both</button>
                    </div>
                </div>

                <!-- Media Type Toggle -->
                <div class="media-type-toggle">
                    <label>Content Type:</label>
                    <div class="toggle-buttons">
                        <button class="toggle-btn active" id="toggle-movie" onclick="setReviewMediaType('movie')">Movie</button>
                        <button class="toggle-btn" id="toggle-tv" onclick="setReviewMediaType('tv')">TV Show</button>
                    </div>
                </div>

                <div class="review-search">
                    <label for="review-search-input">Search for title:</label>
                    <div class="search-row">
                        <input type="text" id="review-search-input" placeholder="Movie or TV show name" autocomplete="off">
                        <button class="btn btn-primary" onclick="searchReviewTitle()">Search</button>
                    </div>
                    <small class="search-hint" id="search-hint">Results from Radarr/TMDB. Click IMDB/TMDB links to verify. Wrong match? Try a different search.</small>
                </div>

                <!-- TV-specific fields (hidden by default) -->
                <div class="tv-options" id="tv-options" style="display: none;">
                    <div class="tv-options-row">
                        <div class="field-group">
                            <label for="tv-season">Season</label>
                            <input type="number" id="tv-season" value="1" min="1" max="99">
                        </div>
                        <div class="field-group">
                            <label for="tv-start-episode">Starting Episode</label>
                            <input type="number" id="tv-start-episode" value="1" min="1" max="999">
                        </div>
                    </div>
                    <small class="tv-hint">For multi-disc seasons: Disc 2 might start at episode 9, etc.</small>

                    <!-- Episode Assignment UI (shown when TV mode + item has tracks) -->
                    <div class="episode-assignment" id="episode-assignment" style="display: none;">
                        <div class="assignment-header">
                            <span>Assign Episodes</span>
                            <span class="episode-count" id="episode-count">- tracks / - episodes</span>
                        </div>
                        <div class="track-list" id="track-list">
                            <!-- Track cards populated dynamically -->
                        </div>
                    </div>
                </div>

                <div class="review-results" id="review-results" style="display: none;">
                    <!-- Results will be dynamically populated -->
                </div>

                <div class="manual-entry-toggle">
                    <a href="#" onclick="toggleManualEntry(); return false;">Can't find it? Enter manually</a>
                </div>

                <div class="manual-entry" id="manual-entry" style="display: none;">
                    <div class="manual-entry-fields">
                        <div class="field-group">
                            <label for="manual-title">Title</label>
                            <input type="text" id="manual-title" placeholder="Movie or show title">
                        </div>
                        <div class="field-group field-year">
                            <label for="manual-year">Year</label>
                            <input type="text" id="manual-year" placeholder="2024" maxlength="4">
                        </div>
                        <div class="field-group field-tmdb">
                            <label for="manual-tmdb">TMDB ID</label>
                            <input type="text" id="manual-tmdb" placeholder="Optional" maxlength="10">
                        </div>
                    </div>
                    <div class="manual-preview">
                        <span class="preview-label">Folder name:</span>
                        <span id="manual-preview-text">-</span>
                        <button class="btn btn-small btn-tmdb-lookup" id="btn-tmdb-lookup" onclick="lookupTmdbId()" style="display: none;">Fetch Info</button>
                    </div>
                </div>

                <div class="review-actions">
                    <button class="btn btn-success" id="btn-apply-review" onclick="applyReviewIdentification()" disabled>Apply Identification</button>
                    <button class="btn btn-danger" onclick="deleteReviewItem()">Delete Rip</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Activity Log -->
    <section class="card activity-log full-width">
        <div class="log-header">
            <h2>Activity Log</h2>
            <div class="log-filters">
                <button class="log-filter active" data-filter="all">All</button>
                <button class="log-filter" data-filter="info">Info</button>
                <button class="log-filter" data-filter="error">Errors</button>
            </div>
        </div>
        <div class="log-container" id="log-container">
            <div class="log-entry info">
                <span class="log-time">--:--:--</span>
                <span class="log-level">INFO</span>
                <span class="log-message">Waiting for activity...</span>
            </div>
        </div>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Load status on page load
    document.addEventListener('DOMContentLoaded', function() {
        // First check rip status - if rip is active, that takes priority over scan results
        fetch('/api/rip/status')
            .then(r => r.json())
            .then(ripStatus => {
                if (ripStatus && ripStatus.status &&
                    !['idle', 'complete', 'error'].includes(ripStatus.status)) {
                    // Active rip in progress - show rip UI, don't restore scan results
                    showRipProgress(ripStatus);
                    discAlreadyProcessed = true;
                } else if (ripStatus && (ripStatus.status === 'complete' || ripStatus.status === 'error')) {
                    // Completed rip - show it
                    showRipProgress(ripStatus);
                } else {
                    // No active rip - restore scan results if any
                    restoreScanResults();
                }
            })
            .catch(() => {
                // On error, try to restore scan results
                restoreScanResults();
            });

        loadStatus();
        loadHardware();
        loadActivityLog();
        loadReviewQueue();     // Load review queue
        startDiscPolling();    // Start polling for disc insertion
        // Refresh status every 2 seconds (faster for progress bar updates)
        setInterval(loadStatus, 2000);
        // Refresh activity log every 5 seconds
        setInterval(loadActivityLog, 5000);
        // Refresh review queue every 30 seconds
        setInterval(loadReviewQueue, 30000);

        // Setup log filter buttons
        document.querySelectorAll('.log-filter').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.log-filter').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                document.getElementById('log-container').setAttribute('data-filter', this.dataset.filter);
            });
        });
    });

    // Load activity log
    function loadActivityLog() {
        fetch('/api/activity-log')
            .then(r => r.json())
            .then(data => {
                const container = document.getElementById('log-container');
                if (!data.log || data.log.length === 0) {
                    container.innerHTML = `
                        <div class="log-entry info">
                            <span class="log-time">--:--:--</span>
                            <span class="log-level">INFO</span>
                            <span class="log-message">No activity logged yet</span>
                        </div>
                    `;
                    return;
                }

                let html = '';
                data.log.forEach(entry => {
                    // Parse log entry format: "YYYY-MM-DD HH:MM:SS | LEVEL | message"
                    // or fallback to simple text
                    let time = '--:--:--';
                    let level = 'info';
                    let message = entry;

                    const match = entry.match(/^(\d{4}-\d{2}-\d{2}\s+)?(\d{2}:\d{2}:\d{2})?\s*\|?\s*(INFO|ERROR|WARN|SUCCESS|DEBUG|START)?\s*\|?\s*(.*)$/i);
                    if (match) {
                        time = match[2] || '--:--:--';
                        level = (match[3] || 'info').toLowerCase();
                        message = match[4] || entry;
                    }

                    // Map log levels
                    if (level === 'warn') level = 'warning';

                    html += `
                        <div class="log-entry ${level}">
                            <span class="log-time">${time}</span>
                            <span class="log-level">${level.toUpperCase()}</span>
                            <span class="log-message">${escapeHtml(message)}</span>
                        </div>
                    `;
                });

                container.innerHTML = html;
            })
            .catch(err => {
                console.error('Error loading activity log:', err);
            });
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Media type toggle functions
    function toggleMediaType() {
        window.currentMediaType = window.currentMediaType === 'tv' ? 'movie' : 'tv';
        updateMediaTypeToggle();
        updateMediaTypeUI();
    }

    function updateMediaTypeToggle() {
        const switchEl = document.querySelector('.media-type-switch');
        const movieOption = document.getElementById('switch-movie');
        const tvOption = document.getElementById('switch-tv');

        if (window.currentMediaType === 'tv') {
            switchEl.classList.add('tv');
            movieOption.classList.remove('active');
            tvOption.classList.add('active');
        } else {
            switchEl.classList.remove('tv');
            movieOption.classList.add('active');
            tvOption.classList.remove('active');
        }
    }

    function updateMediaTypeUI() {
        const isTV = window.currentMediaType === 'tv';
        const tvSeasonEdit = document.getElementById('tv-season-edit');
        const tvEpisodeList = document.getElementById('tv-episode-list');
        const titleInput = document.getElementById('custom-title');
        const statusSubtitle = document.querySelector('.status-subtitle');

        // Show/hide TV controls
        tvSeasonEdit.style.display = isTV ? 'flex' : 'none';
        tvEpisodeList.style.display = isTV && window.currentScanData?.episode_tracks?.length > 0 ? 'block' : 'none';

        // Update placeholder
        titleInput.placeholder = isTV ? "Series Name" : "Movie Title (Year)";

        // Update subtitle
        if (isTV) {
            const seasonNum = document.getElementById('season-number')?.value || 1;
            const epCount = window.currentScanData?.episode_tracks?.length || 0;
            statusSubtitle.textContent = `TV Show - Season ${seasonNum} (${epCount} episodes)`;
        } else {
            statusSubtitle.textContent = 'Movie - verify title and year';
        }

        // Update rip button text for new media type
        updateRipButtonText(titleInput.value.trim(), isTV);
    }

    // Restore scan results from backend (persists across page navigation)
    function restoreScanResults() {
        // Try sessionStorage first, then backend API
        let savedData = null;
        const sessionSaved = sessionStorage.getItem('scanResults');
        if (sessionSaved) {
            try {
                savedData = JSON.parse(sessionSaved);
            } catch (e) {
                sessionStorage.removeItem('scanResults');
            }
        }

        // Always verify disc label matches before displaying
        if (savedData && savedData.disc_label) {
            fetch('/api/disc/check')
                .then(r => r.json())
                .then(discInfo => {
                    if (discInfo.present && discInfo.label === savedData.disc_label) {
                        displayScanResults(savedData);
                    } else {
                        // Disc changed - clear stale data
                        sessionStorage.removeItem('scanResults');
                    }
                })
                .catch(() => {});
            return;
        }

        // No sessionStorage - try backend API
        fetch('/api/disc/last-scan')
            .then(r => r.json())
            .then(data => {
                if (data && data.disc_label) {
                    fetch('/api/disc/check')
                        .then(r => r.json())
                        .then(discInfo => {
                            if (discInfo.present && discInfo.label === data.disc_label) {
                                saveScanResults(data);
                                displayScanResults(data);
                            }
                        });
                }
            })
            .catch(() => {});
    }

    // Save scan results to sessionStorage
    function saveScanResults(data) {
        sessionStorage.setItem('scanResults', JSON.stringify(data));
    }

    // Get saved scan results
    function getScanResults() {
        const saved = sessionStorage.getItem('scanResults');
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {
                return null;
            }
        }
        return null;
    }

    // Clear scan results
    function clearScanResults() {
        sessionStorage.removeItem('scanResults');
        document.getElementById('scan-results').style.display = 'none';
        document.getElementById('auto-rip-countdown').style.display = 'none';
        document.getElementById('btn-start-rip').textContent = 'Start Rip';
        showingScanResults = false;
        cancelCountdown();
    }

    // Display scan results in the UI
    function displayScanResults(data) {
        showingScanResults = true;

        // Store scan data for later use
        window.currentScanData = data;

        // Update status text
        const statusTitle = document.querySelector('.status-title');
        const statusSubtitle = document.querySelector('.status-subtitle');

        // Check if this is a TV disc
        const isTVDisc = data.media_type === 'tv' || data.is_tv_disc;

        if (data.identified) {
            statusTitle.textContent = data.identified.title;
            if (isTVDisc) {
                const seasonNum = data.season_number || 1;
                const epCount = data.episode_tracks ? data.episode_tracks.length : 0;
                statusSubtitle.textContent = `TV Show - Season ${seasonNum} (${epCount} episodes, ${data.identified.confidence}% confidence)`;
            } else {
                statusSubtitle.textContent = `Identified with ${data.identified.confidence}% confidence`;
            }
        } else {
            statusTitle.textContent = data.parsed_search || data.disc_label;
            if (isTVDisc) {
                statusSubtitle.textContent = 'TV Show detected - please verify series and season';
            } else {
                statusSubtitle.textContent = 'Could not auto-identify - please verify title';
            }
        }

        // Show scan results section
        const scanResults = document.getElementById('scan-results');
        scanResults.style.display = 'block';

        // Fill in disc info
        document.getElementById('scan-disc-type').textContent = (data.disc_type || 'DISC').toUpperCase();
        document.getElementById('scan-disc-label').textContent = data.disc_label;

        // Set up media type toggle
        const mediaTypeToggle = document.getElementById('media-type-toggle');
        window.currentMediaType = isTVDisc ? 'tv' : 'movie';
        updateMediaTypeToggle();

        // Runtime - show total for TV, main feature for movies
        if (isTVDisc && data.episode_tracks && data.episode_tracks.length > 0) {
            const totalDuration = data.episode_tracks.reduce((sum, t) => sum + t.duration, 0);
            const hours = Math.floor(totalDuration / 3600);
            const mins = Math.floor((totalDuration % 3600) / 60);
            document.getElementById('scan-runtime').textContent = hours > 0 ? `${hours}h ${mins}m total` : `${mins}m total`;
        } else if (data.main_feature !== null && data.tracks) {
            const track = data.tracks.find(t => t.index === data.main_feature);
            if (track) {
                document.getElementById('scan-runtime').textContent = track.duration_str;
            }
        }

        // Expected size
        if (data.expected_size_str) {
            document.getElementById('scan-size').textContent = data.expected_size_str;
        } else {
            document.getElementById('scan-size').textContent = '';
        }

        // Fill in editable title
        const titleInput = document.getElementById('custom-title');
        titleInput.value = data.suggested_title || data.parsed_search || data.disc_label;
        titleInput.placeholder = isTVDisc ? "Series Name" : "Movie Title (Year)";

        // Show TV-specific controls
        const tvSeasonEdit = document.getElementById('tv-season-edit');
        const tvEpisodeList = document.getElementById('tv-episode-list');

        if (isTVDisc) {
            // Show season editor
            tvSeasonEdit.style.display = 'flex';
            document.getElementById('season-number').value = data.season_number || 1;

            // Show episode list
            if (data.episode_tracks && data.episode_tracks.length > 0) {
                tvEpisodeList.style.display = 'block';
                populateEpisodeList(data.episode_tracks, data.episode_mapping || {});
            }
        } else {
            tvSeasonEdit.style.display = 'none';
            tvEpisodeList.style.display = 'none';
        }

        // Show confidence badge if identified
        const badge = document.getElementById('confidence-badge');
        if (data.identified && data.identified.confidence) {
            badge.style.display = 'inline';
            if (data.identified.confidence >= 75) {
                badge.textContent = 'HIGH';
                badge.className = 'confidence-badge high';
            } else if (data.identified.confidence >= 50) {
                badge.textContent = 'MEDIUM';
                badge.className = 'confidence-badge medium';
            } else {
                badge.textContent = 'LOW';
                badge.className = 'confidence-badge low';
            }
        } else {
            badge.style.display = 'none';
        }

        // Show identification methods as clickable cards
        const methodsContainer = document.getElementById('id-methods');
        const methodsList = document.getElementById('id-methods-list');
        if (data.identification_methods && data.identification_methods.length > 0) {
            // Sort by confidence (highest first) and store for click handling
            const sortedMethods = [...data.identification_methods].sort((a, b) => b.confidence - a.confidence);
            window.idMethods = sortedMethods;
            methodsContainer.style.display = 'block';
            let html = '';
            sortedMethods.forEach((method, idx) => {
                const confClass = method.confidence >= 75 ? 'high' : (method.confidence >= 50 ? 'medium' : 'low');
                const isSelected = method.result === titleInput.value;
                html += `
                    <div class="id-method ${isSelected ? 'selected' : ''}" onclick="selectIdMethod(${idx})" title="Click to use this title">
                        <div class="id-method-header">
                            <span class="id-method-name">${method.method}</span>
                            <span class="id-method-conf ${confClass}">${method.confidence}%</span>
                        </div>
                        <div class="id-method-result">${escapeHtml(method.result)}</div>
                        <div class="id-method-details">${escapeHtml(method.details)}</div>
                    </div>
                `;
            });
            methodsList.innerHTML = html;

            // Auto-select the highest confidence method (first in sorted list)
            if (sortedMethods.length > 0) {
                selectIdMethod(0, true);  // true = auto-selection, don't cancel countdown
            }
        } else {
            methodsContainer.style.display = 'none';
        }

        // Set IMDB search link - use TV search for TV discs
        const imdbBtn = document.getElementById('imdb-search-btn');
        const searchTerm = data.parsed_search || data.disc_label.replace(/_/g, ' ');
        if (isTVDisc) {
            imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(searchTerm)}&s=tt&ttype=tv`;
        } else {
            imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(searchTerm)}&s=tt&ttype=ft`;
        }

        // Update IMDB link and rip button when title input changes
        titleInput.addEventListener('input', function() {
            const term = this.value.trim() || searchTerm;
            if (isTVDisc) {
                imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(term)}&s=tt&ttype=tv`;
            } else {
                imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(term)}&s=tt&ttype=ft`;
            }
            // Update rip button to show what will be ripped
            updateRipButtonText(this.value.trim(), isTVDisc);
            // Cancel countdown if user is editing
            cancelCountdown();
            // Clear card selection when user types manually
            document.querySelectorAll('.id-method').forEach(el => el.classList.remove('selected'));
            // Clear stored TMDB data since user is entering custom title
            window.selectedTmdbId = null;
            window.selectedYear = null;
            window.selectedPosterUrl = null;
        });

        // Set initial button text
        updateRipButtonText(titleInput.value.trim(), isTVDisc);

        // Only start auto-rip countdown if confident identification
        // If needs_review is true, wait for user to confirm
        if (data.needs_review) {
            // Show review needed banner
            if (isTVDisc) {
                statusSubtitle.textContent = '‚ö†Ô∏è Please verify series name and season before ripping';
            } else {
                statusSubtitle.textContent = '‚ö†Ô∏è Low confidence - please verify title before ripping';
            }
        } else {
            // Start auto-rip countdown
            startCountdown();
        }
    }

    // Populate the episode list for TV discs
    function populateEpisodeList(episodeTracks, episodeMapping) {
        const container = document.getElementById('episode-items');
        let html = '';

        episodeTracks.forEach((track, idx) => {
            const epInfo = episodeMapping[track.index] || {};
            const epNum = epInfo.episode_number || (idx + 1);
            const epTitle = epInfo.title || `Episode ${epNum}`;
            const duration = track.duration_str || formatDuration(track.duration);

            html += `
                <div class="episode-item" data-track="${track.index}">
                    <label class="episode-checkbox">
                        <input type="checkbox" class="ep-select" data-track="${track.index}" checked>
                    </label>
                    <span class="episode-number">E${epNum.toString().padStart(2, '0')}</span>
                    <span class="episode-title">${escapeHtml(epTitle)}</span>
                    <span class="episode-duration">${duration}</span>
                </div>
            `;
        });

        container.innerHTML = html;

        // Setup select-all checkbox
        document.getElementById('select-all-episodes').addEventListener('change', function() {
            document.querySelectorAll('.ep-select').forEach(cb => cb.checked = this.checked);
            updateRipButtonForTV();
        });

        // Update rip button when individual episodes are toggled
        document.querySelectorAll('.ep-select').forEach(cb => {
            cb.addEventListener('change', updateRipButtonForTV);
        });
    }

    function formatDuration(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function updateRipButtonForTV() {
        const selectedCount = document.querySelectorAll('.ep-select:checked').length;
        const totalCount = document.querySelectorAll('.ep-select').length;
        const titleInput = document.getElementById('custom-title');
        const title = titleInput.value.trim();

        if (selectedCount === 0) {
            document.getElementById('btn-start-rip').textContent = 'Select Episodes';
            document.getElementById('btn-start-rip').disabled = true;
        } else {
            document.getElementById('btn-start-rip').disabled = false;
            if (title) {
                document.getElementById('btn-start-rip').textContent = `Rip ${selectedCount} Episode${selectedCount > 1 ? 's' : ''}`;
            } else {
                document.getElementById('btn-start-rip').textContent = `Rip ${selectedCount} Episode${selectedCount > 1 ? 's' : ''}`;
            }
        }
    }

    // Get selected episode tracks for TV rip
    function getSelectedEpisodeTracks() {
        const selected = [];
        document.querySelectorAll('.ep-select:checked').forEach(cb => {
            selected.push(parseInt(cb.dataset.track));
        });
        return selected;
    }

    function loadHardware() {
        fetch('/api/hardware')
            .then(r => r.json())
            .then(data => {
                document.getElementById('hw-hostname').textContent = data.hostname || '-';

                // CPU - show cores on second line if present
                let cpuHtml = data.cpu;
                if (data.cpu_cores) {
                    cpuHtml += `<br><span class="hw-subtext">${data.cpu_cores} cores</span>`;
                }
                document.getElementById('hw-cpu').innerHTML = cpuHtml;

                // Memory - include type and speed if available
                let ramText = data.ram_used_gb + ' GB used / ' + data.ram_gb + ' GB';
                if (data.ram_type || data.ram_speed) {
                    let ramExtra = [];
                    if (data.ram_type) ramExtra.push(data.ram_type);
                    if (data.ram_speed) ramExtra.push(data.ram_speed);
                    ramText += `<br><span class="hw-subtext">${ramExtra.join(' ')}</span>`;
                }
                document.getElementById('hw-ram').innerHTML = ramText;

                document.getElementById('hw-os').textContent = data.os || '-';

                // IP Address - show interface type if available
                let ipText = data.ip_address || '-';
                if (data.network_interface) {
                    ipText += ` (${data.network_interface})`;
                }
                document.getElementById('hw-ip').textContent = ipText;

                document.getElementById('hw-uptime').textContent = data.uptime || '-';
                document.getElementById('hw-docker').textContent = data.docker_version || '-';

                // GPU - prefer discrete, fall back to integrated
                if (data.gpu) {
                    document.getElementById('hw-gpu').textContent = data.gpu;
                    document.getElementById('hw-gpu-row').style.display = 'flex';
                } else if (data.integrated_gpu) {
                    document.getElementById('hw-gpu').textContent = data.integrated_gpu + ' (integrated)';
                    document.getElementById('hw-gpu-row').style.display = 'flex';
                }

                // Storage drives (mounted)
                const storageContainer = document.getElementById('hw-storage-rows');
                storageContainer.innerHTML = '';
                if (data.storage && data.storage.length > 0) {
                    data.storage.forEach(drive => {
                        const row = document.createElement('div');
                        row.className = 'hw-row';
                        // Format: "media (HDD)" or "storage (SSD)"
                        let label = drive.mount.replace('/mnt/', '').replace('/media/', '');
                        if (drive.type) {
                            label += ` <span class="drive-type">${drive.type}</span>`;
                        }
                        // Fix df's 1% minimum - show 0% if used is tiny (KB range)
                        let percent = drive.percent;
                        if (drive.used.endsWith('K') && percent === '1%') {
                            percent = '0%';
                        }
                        row.innerHTML = `
                            <span class="hw-label">${label}</span>
                            <span class="hw-value">${drive.used} / ${drive.size} (${percent})</span>
                        `;
                        storageContainer.appendChild(row);
                    });
                } else if (data.disk_total) {
                    // Fallback to single media drive
                    const row = document.createElement('div');
                    row.className = 'hw-row';
                    row.innerHTML = `
                        <span class="hw-label">Media</span>
                        <span class="hw-value">${data.disk_used} / ${data.disk_total} (${data.disk_percent}%)</span>
                    `;
                    storageContainer.appendChild(row);
                }

                // Physical drives (show as expandable details)
                if (data.drives && data.drives.length > 0) {
                    const drivesRow = document.createElement('div');
                    drivesRow.className = 'hw-row hw-drives-toggle';
                    drivesRow.innerHTML = `
                        <span class="hw-label">Physical Drives <span class="toggle-arrow">‚ñ∏</span></span>
                        <span class="hw-value">${data.drives.length} drives</span>
                    `;
                    const drivesList = document.createElement('div');
                    drivesList.className = 'hw-drives-list';
                    drivesList.style.display = 'none';
                    data.drives.forEach(drive => {
                        const driveRow = document.createElement('div');
                        driveRow.className = 'hw-row hw-row-nested';
                        driveRow.innerHTML = `
                            <span class="hw-label">${drive.name.replace('/dev/', '')} <span class="drive-type">${drive.type}</span></span>
                            <span class="hw-value">${drive.size}<br><span class="hw-subtext">${drive.model}</span></span>
                        `;
                        drivesList.appendChild(driveRow);
                    });
                    storageContainer.appendChild(drivesRow);
                    storageContainer.appendChild(drivesList);

                    // Toggle click handler
                    drivesRow.onclick = () => {
                        const isHidden = drivesList.style.display === 'none';
                        drivesList.style.display = isHidden ? 'block' : 'none';
                        drivesRow.querySelector('.toggle-arrow').textContent = isHidden ? '‚ñæ' : '‚ñ∏';
                    };
                }

                // Optical drive
                if (data.optical_drives && data.optical_drives.length > 0) {
                    document.getElementById('hw-optical').textContent = data.optical_drives[0].model || data.optical_drives[0].device;
                }

                // Ned monitoring agent (cross-promotion)
                if (data.ned && data.ned.installed) {
                    document.getElementById('ned-footer').style.display = 'block';
                    const nedLink = document.getElementById('ned-link');
                    if (data.ned.dashboard_url) {
                        nedLink.href = data.ned.dashboard_url;
                        nedLink.title = 'View server in Ned dashboard';
                    }
                }
            })
            .catch(err => console.error('Error loading hardware:', err));

        // Load version info (daily auto-check)
        const lastCheck = localStorage.getItem('ripforge_last_update_check');
        const cachedUpdate = localStorage.getItem('ripforge_update_available');
        const cachedLatest = localStorage.getItem('ripforge_latest_version');
        const oneDayMs = 24 * 60 * 60 * 1000;
        const shouldCheck = !lastCheck || (Date.now() - new Date(lastCheck).getTime()) > oneDayMs;

        function updateVersionUI(data) {
            const versionEl = document.getElementById('version-number');
            const dotEl = document.getElementById('version-dot');
            const updateBtn = document.getElementById('btn-update');
            const updateHint = document.getElementById('update-hint');
            versionEl.textContent = 'v' + data.current_version;

            if (data.error) {
                dotEl.className = 'version-dot unknown';
                dotEl.title = 'Unable to check for updates';
                updateBtn.style.display = 'none';
                updateHint.textContent = '';
            } else if (data.update_available) {
                dotEl.className = 'version-dot update-available';
                dotEl.title = 'Update available: v' + data.latest_version;
                updateBtn.style.display = 'inline-block';
                updateHint.textContent = 'v' + data.latest_version + ' available';
            } else {
                dotEl.className = 'version-dot up-to-date';
                dotEl.title = 'Up to date';
                updateBtn.style.display = 'none';
                updateHint.textContent = '';
            }
        }

        // Simple semver comparison: returns true if v1 > v2
        function isNewerVersion(v1, v2) {
            if (!v1 || !v2) return false;
            const p1 = v1.replace(/^v/, '').split('.').map(Number);
            const p2 = v2.replace(/^v/, '').split('.').map(Number);
            for (let i = 0; i < Math.max(p1.length, p2.length); i++) {
                const a = p1[i] || 0, b = p2[i] || 0;
                if (a > b) return true;
                if (a < b) return false;
            }
            return false;
        }

        if (shouldCheck) {
            fetch('/api/version')
                .then(r => r.json())
                .then(data => {
                    localStorage.setItem('ripforge_last_update_check', new Date().toISOString());
                    localStorage.setItem('ripforge_update_available', data.update_available ? 'true' : 'false');
                    localStorage.setItem('ripforge_latest_version', data.latest_version || '');
                    updateVersionUI(data);
                })
                .catch(err => console.error('Error loading version:', err));
        } else {
            // Use cached status, but verify cached version is actually newer than current
            fetch('/api/version')
                .then(r => r.json())
                .then(data => {
                    // Only show update if cached latest is actually NEWER than current
                    if (cachedUpdate === 'true' && cachedLatest && isNewerVersion(cachedLatest, data.current_version)) {
                        data.update_available = true;
                        data.latest_version = cachedLatest;
                    } else {
                        data.update_available = false;
                        // Clear stale cache
                        localStorage.removeItem('ripforge_update_available');
                        localStorage.removeItem('ripforge_latest_version');
                    }
                    updateVersionUI(data);
                })
                .catch(err => console.error('Error loading version:', err));
        }
    }

    function performUpdate() {
        const updateBtn = document.getElementById('btn-update');
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';

        fetch('/api/update', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    // Clear update cache so stale versions don't show after update
                    localStorage.removeItem('ripforge_update_available');
                    localStorage.removeItem('ripforge_latest_version');
                    localStorage.removeItem('ripforge_last_update_check');
                    showToast('Update installed!', 'success');
                    countdownReload(updateBtn, 5);
                } else {
                    showToast('Update failed: ' + (data.error || 'Unknown error'), 'error');
                    updateBtn.disabled = false;
                    updateBtn.textContent = 'Update';
                }
            })
            .catch(err => {
                // Connection lost likely means service restarted
                countdownReload(updateBtn, 5);
            });
    }

    function countdownReload(btn, seconds) {
        let remaining = seconds;
        btn.textContent = `Restarting ${remaining}...`;
        const interval = setInterval(() => {
            remaining--;
            if (remaining > 0) {
                btn.textContent = `Restarting ${remaining}...`;
            } else {
                clearInterval(interval);
                btn.textContent = 'Reloading...';
                window.location.reload();
            }
        }, 1000);
    }

    document.getElementById('btn-update').addEventListener('click', performUpdate);

    function loadStatus() {
        fetch('/api/status')
            .then(r => r.json())
            .then(data => {
                // Update integration status (sidebar dots)
                for (const [service, status] of Object.entries(data.integrations)) {
                    const el = document.getElementById('int-' + service);
                    if (el) {
                        if (!status.enabled) {
                            el.className = 'int-dot disabled';
                        } else if (status.connected) {
                            el.className = 'int-dot connected';
                        } else {
                            el.className = 'int-dot error';
                        }
                    }
                }

                // Live RAM update
                if (data.ram) {
                    const ramEl = document.getElementById('hw-ram');
                    if (ramEl) {
                        // Preserve the existing subtext (type/speed) if present
                        const existingHtml = ramEl.innerHTML;
                        const subtextMatch = existingHtml.match(/<br><span class="hw-subtext">([^<]+)<\/span>/);
                        let ramHtml = data.ram.used_gb + ' GB used / ' + data.ram.total_gb + ' GB';
                        if (subtextMatch) {
                            ramHtml += '<br><span class="hw-subtext">' + subtextMatch[1] + '</span>';
                        }
                        ramEl.innerHTML = ramHtml;
                    }
                }

                // Update rip status
                if (data.ripping) {
                    showRipProgress(data.ripping);
                } else {
                    showIdleState();
                }
            })
            .catch(err => console.error('Error loading status:', err));
    }

    // Update rip button to show the title that will be used
    function updateRipButtonText(title, isTVDisc = false) {
        const btn = document.getElementById('btn-start-rip');
        if (isTVDisc) {
            // For TV, call the TV-specific update function
            updateRipButtonForTV();
        } else if (title) {
            // Truncate long titles
            const displayTitle = title.length > 30 ? title.substring(0, 27) + '...' : title;
            btn.textContent = `Rip "${displayTitle}"`;
            btn.disabled = false;
        } else {
            btn.textContent = 'Start Rip';
            btn.disabled = false;
        }
    }

    // Select an identification method by clicking its card
    // autoSelect=true means this is auto-selection on load, don't cancel countdown
    function selectIdMethod(idx, autoSelect = false) {
        const methods = window.idMethods || [];
        if (idx < 0 || idx >= methods.length) return;

        const method = methods[idx];
        const titleInput = document.getElementById('custom-title');

        // Update title input with the result
        titleInput.value = method.result;

        // Store TMDB data if available (for when rip starts)
        if (method.tmdb_id) {
            window.selectedTmdbId = method.tmdb_id;
            window.selectedYear = method.year;
            window.selectedPosterUrl = method.poster_url;
        }

        // Update visual selection
        document.querySelectorAll('.id-method').forEach((el, i) => {
            el.classList.toggle('selected', i === idx);
        });

        // Update rip button and IMDB link
        const isTVDisc = window.currentMediaType === 'tv';
        updateRipButtonText(method.result, isTVDisc);
        const imdbBtn = document.getElementById('imdb-search-btn');
        const searchTerm = method.title || method.result;
        if (isTVDisc) {
            imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(searchTerm)}&s=tt&ttype=tv`;
        } else {
            imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(searchTerm)}&s=tt&ttype=ft`;
        }

        // Cancel auto-rip countdown since user is interacting (but not for auto-selection)
        if (!autoSelect) cancelCountdown();

        showToast(`Selected: ${method.result}`, 'success');
    }

    // Checklist UI Functions
    // Track if we're showing scan results (don't overwrite with idle)
    let showingScanResults = false;
    // Track if scan is in progress (don't let polling reset UI)
    let scanInProgress = false;
    // Auto-rip countdown
    let countdownInterval = null;
    let countdownSeconds = 20;
    const AUTO_RIP_ENABLED = {{ config.get('ripping', {}).get('auto_rip', true) | tojson }};
    const AUTO_RIP_DELAY = {{ config.get('ripping', {}).get('auto_rip_delay', 20) }};
    const AUTO_SCAN_ON_INSERT = {{ config.get('ripping', {}).get('auto_scan_on_insert', true) | tojson }};
    const HANDS_FREE = {{ config.get('ripping', {}).get('hands_free', false) | tojson }};

    // Disc insert polling
    let lastDiscState = false;
    let discPollInterval = null;
    let discAlreadyProcessed = false;  // Track if current disc was already scanned/ripped
    let processedDiscLabel = sessionStorage.getItem('processedDiscLabel') || null;  // Persist across refresh

    function startDiscPolling() {
        if (!AUTO_SCAN_ON_INSERT) return;

        discPollInterval = setInterval(() => {
            // Don't poll if scan is in progress
            if (scanInProgress) return;

            // If disc already processed and still present, only do lightweight status check
            // Don't hit the drive with blkid repeatedly
            if (discAlreadyProcessed && lastDiscState) {
                // Just check rip status, don't hit the drive
                fetch('/api/rip/status')
                    .then(r => r.json())
                    .then(ripStatus => {
                        // If rip just completed, we still have disc - wait for eject
                        // Only do a disc check occasionally (every 10 seconds via counter)
                    })
                    .catch(() => {});
                return;
            }

            // First check if a rip is already running
            fetch('/api/rip/status')
                .then(r => r.json())
                .then(ripStatus => {
                    // If rip is active, mark disc as processed and don't scan
                    if (ripStatus && ripStatus.status &&
                        !['idle', 'complete', 'error'].includes(ripStatus.status)) {
                        discAlreadyProcessed = true;
                        return null; // Skip disc check
                    }
                    return fetch('/api/disc/check').then(r => r.json());
                })
                .then(data => {
                    if (!data) return; // Skipped because rip is running

                    const discPresent = data.present;

                    // Disc was ejected - reset everything for the next disc
                    if (!discPresent && lastDiscState) {
                        console.log('Disc ejected, resetting for new disc');
                        discAlreadyProcessed = false;
                        processedDiscLabel = null;
                        sessionStorage.removeItem('processedDiscLabel');
                        showingScanResults = false;
                        clearScanResults();
                        // Also reset the backend job so UI goes back to ready state
                        fetch('/api/rip/reset', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        }).then(() => {
                            // Reset UI to idle state
                            document.getElementById('rip-checklist').style.display = 'none';
                            document.getElementById('status-idle').style.display = 'block';
                            document.querySelector('.status-title').textContent = 'Ready';
                            document.querySelector('.status-subtitle').textContent = 'Insert a disc to begin';
                        }).catch(() => {});
                    }

                    // Detect disc insertion (was not present, now present, not already processed)
                    if (discPresent && !lastDiscState && !discAlreadyProcessed) {
                        // Check if this disc was already processed (survives page refresh)
                        if (data.label && data.label === processedDiscLabel) {
                            console.log('Disc already processed (from sessionStorage), skipping scan');
                            discAlreadyProcessed = true;
                        } else if (HANDS_FREE) {
                            // Hands-free mode: skip scan, start rip immediately
                            console.log('Disc inserted, hands-free mode - starting rip immediately...');
                            discAlreadyProcessed = true;
                            startHandsFreeRip(data.label);
                        } else {
                            console.log('Disc inserted, auto-scanning...');
                            discAlreadyProcessed = true;
                            scanDisc();
                        }
                    }

                    lastDiscState = discPresent;
                })
                .catch(() => {});
        }, 3000); // Poll every 3 seconds (reduced from 2)
    }

    function stopDiscPolling() {
        if (discPollInterval) {
            clearInterval(discPollInterval);
            discPollInterval = null;
        }
    }

    function startCountdown() {
        if (!AUTO_RIP_ENABLED) return;

        countdownSeconds = AUTO_RIP_DELAY;
        const countdownEl = document.getElementById('auto-rip-countdown');
        const numberEl = document.getElementById('countdown-number');
        const secondsEl = document.getElementById('countdown-seconds');
        const circleEl = document.getElementById('countdown-circle');

        // Show countdown
        countdownEl.style.display = 'flex';

        // Calculate circle circumference (2 * PI * r)
        const circumference = 2 * Math.PI * 45;
        circleEl.style.strokeDasharray = circumference;

        function updateCountdown() {
            numberEl.textContent = countdownSeconds;
            secondsEl.textContent = countdownSeconds;

            // Update ring progress
            const progress = countdownSeconds / AUTO_RIP_DELAY;
            const offset = circumference * (1 - progress);
            circleEl.style.strokeDashoffset = offset;

            if (countdownSeconds <= 0) {
                cancelCountdown();
                startRip();
            } else {
                countdownSeconds--;
            }
        }

        updateCountdown();
        countdownInterval = setInterval(updateCountdown, 1000);
    }

    function cancelCountdown() {
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }
        document.getElementById('auto-rip-countdown').style.display = 'none';
    }

    function showIdleState() {
        document.getElementById('status-idle').style.display = 'block';
        document.getElementById('rip-checklist').style.display = 'none';

        // Hide action buttons that shouldn't show when idle
        document.getElementById('btn-stop').style.display = 'none';
        document.getElementById('btn-reset-rip').style.display = 'none';
        document.getElementById('btn-reset-drive').style.display = 'none';
        document.getElementById('btn-restart-service').style.display = 'none';

        // Only reset to "Ready" if not showing scan results and not scanning
        if (!showingScanResults && !scanInProgress) {
            document.querySelector('.status-title').textContent = 'Ready';
            document.querySelector('.status-subtitle').textContent = 'Insert a disc to begin';
        }
    }

    function showRipProgress(ripData) {
        document.getElementById('status-idle').style.display = 'none';
        document.getElementById('rip-checklist').style.display = 'block';

        // Update title - handle TV shows with season info
        let displayTitle = ripData.identified_title || ripData.disc_label || 'Processing disc...';
        if (ripData.media_type === 'tv' && ripData.season_number) {
            displayTitle = `${ripData.series_title || ripData.identified_title} S${ripData.season_number.toString().padStart(2, '0')}`;
        }
        document.querySelector('.disc-label').textContent = displayTitle;

        // Show disc type badge (DVD/Blu-ray)
        const discTypeBadge = document.getElementById('rip-disc-type');
        if (ripData.disc_type) {
            discTypeBadge.textContent = ripData.disc_type.toUpperCase();
            discTypeBadge.style.display = 'inline-block';
        } else {
            discTypeBadge.style.display = 'none';
        }

        // Show media type badge (TV/Movie) - only after detection completes (early identification)
        const mediaTypeBadge = document.getElementById('rip-media-type');
        const detectStep = ripData.steps?.detect;
        const detectComplete = detectStep && detectStep.status === 'complete';
        if (ripData.media_type && detectComplete) {
            mediaTypeBadge.textContent = ripData.media_type === 'tv' ? 'TV' : 'MOVIE';
            mediaTypeBadge.className = 'media-type-badge ' + (ripData.media_type === 'tv' ? 'tv' : 'movie');
            mediaTypeBadge.style.display = 'inline-block';
        } else {
            mediaTypeBadge.style.display = 'none';
        }

        // Show duplicate warning badge if applicable
        let dupBadge = document.getElementById('duplicate-badge');
        if (!dupBadge) {
            // Create badge element if it doesn't exist
            dupBadge = document.createElement('span');
            dupBadge.id = 'duplicate-badge';
            dupBadge.className = 'duplicate-badge';
            document.querySelector('.disc-label').parentElement.appendChild(dupBadge);
        }
        if (ripData.possible_duplicate) {
            dupBadge.textContent = '‚ö† Possible Duplicate';
            dupBadge.style.display = 'inline-block';
            dupBadge.title = `Match type: ${ripData.duplicate_match_type}`;
        } else {
            dupBadge.style.display = 'none';
        }

        // Update each step and find current active step
        const steps = ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'];
        const stepNames = {
            'insert': 'Inserting',
            'detect': 'Detecting',
            'scan': 'Scanning',
            'rip': 'Ripping',
            'identify': 'Identifying',
            'library': 'Library',
            'move': 'Moving',
            'scan-plex': 'Plex Scan'
        };
        let currentStepName = '';
        steps.forEach(step => {
            const stepData = ripData.steps ? ripData.steps[step] : null;
            if (stepData) {
                updateStep('step-' + step, stepData.status, stepData.detail);
                if (stepData.status === 'active') {
                    currentStepName = stepNames[step] || step;
                }
            }
        });

        // Update rip substeps for compact single-line display
        updateRipSubsteps(ripData);

        // Show current step or completion status
        const currentStepEl = document.getElementById('current-step');
        if (ripData.status === 'complete') {
            currentStepEl.textContent = 'Complete';
            currentStepEl.className = 'current-step complete';
            // Save disc label to prevent re-scan on page refresh
            if (ripData.disc_label) {
                processedDiscLabel = ripData.disc_label;
                sessionStorage.setItem('processedDiscLabel', ripData.disc_label);
            }
        } else if (ripData.status === 'error') {
            currentStepEl.textContent = 'Error';
            currentStepEl.className = 'current-step error';
        } else if (currentStepName) {
            currentStepEl.textContent = currentStepName;
            currentStepEl.className = 'current-step active';
        } else {
            currentStepEl.textContent = '';
        }

        // Update progress bar if ripping (show when rip step is active or progress > 0)
        const ripStepActive = ripData.steps && ripData.steps.rip && ripData.steps.rip.status === 'active';
        if (ripStepActive || (ripData.progress !== undefined && ripData.progress > 0)) {
            document.getElementById('rip-progress').style.display = 'block';
            const pct = ripData.progress || 0;
            document.getElementById('progress-fill').style.width = pct + '%';
            document.getElementById('progress-text').textContent = pct + '%';

            // Show file size progress
            const sizeEl = document.getElementById('progress-size');
            if (ripData.current_size_bytes > 0 || ripData.expected_size_bytes > 0) {
                const currentGB = (ripData.current_size_bytes || 0) / (1024*1024*1024);
                const expectedGB = (ripData.expected_size_bytes || 0) / (1024*1024*1024);
                if (expectedGB > 0) {
                    sizeEl.textContent = `${currentGB.toFixed(1)} / ${Math.ceil(expectedGB * 10) / 10} GB`;
                } else {
                    sizeEl.textContent = `${currentGB.toFixed(1)} GB`;
                }
            } else {
                sizeEl.textContent = '';
            }

            // Show episode progress for TV
            const etaEl = document.getElementById('progress-eta');
            if (ripData.status === 'complete') {
                etaEl.textContent = 'Completed';
            } else if (ripData.media_type === 'tv' && ripData.total_tracks > 0) {
                const currentEp = (ripData.current_track_index || 0) + 1;
                etaEl.textContent = `Episode ${currentEp} of ${ripData.total_tracks}`;
            } else if (ripData.eta) {
                etaEl.textContent = ripData.eta;
            } else if (pct === 0) {
                etaEl.textContent = 'Starting...';
            } else if (pct >= 100) {
                etaEl.textContent = 'Finishing...';
            } else {
                // Progress is active but no ETA - show percentage remaining
                etaEl.textContent = `${100 - pct}% remaining`;
            }
        } else {
            document.getElementById('rip-progress').style.display = 'none';
        }

        // Manage button visibility based on status
        const resetBtn = document.getElementById('btn-reset-rip');
        const stopBtn = document.getElementById('btn-stop');
        const ejectBtn = document.getElementById('btn-eject');
        const isActive = ['detecting', 'scanning', 'ripping', 'identifying', 'moving'].includes(ripData.status);

        if (ripData.status === 'error' || ripData.status === 'complete') {
            // Rip finished - show Reset, hide Stop
            resetBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            document.getElementById('post-rip-actions').style.display = 'block';
            // Show recovery buttons on error
            if (ripData.status === "error") {
                document.getElementById("btn-reset-drive").style.display = "inline-block";
                document.getElementById("btn-restart-service").style.display = "inline-block";
            } else {
                document.getElementById("btn-reset-drive").style.display = "none";
                document.getElementById("btn-restart-service").style.display = "none";
            }
            // Eject enabled unless disc already ejected
            ejectBtn.disabled = ripData.disc_ejected === true;
            document.getElementById('btn-start-rip').disabled = false;
            document.getElementById('btn-start-rip').textContent = 'Start Rip';
        } else if (isActive) {
            // Process in progress - show Stop, hide Reset, disable Eject
            resetBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            ejectBtn.disabled = true;
            document.getElementById("btn-reset-drive").style.display = "none";
            document.getElementById("btn-restart-service").style.display = "none";
            if (document.getElementById('post-rip-actions')) document.getElementById('post-rip-actions').style.display = 'none';
        } else {
            // Idle - hide Stop and Reset, enable Eject if disc present
            resetBtn.style.display = 'none';
            stopBtn.style.display = 'none';
            ejectBtn.disabled = !ripData.disc_present;
            document.getElementById("btn-reset-drive").style.display = "none";
            document.getElementById("btn-restart-service").style.display = "none";
        }
    }

    function updateStep(stepId, status, detail) {
        const step = document.getElementById(stepId);
        if (!step) return;

        step.setAttribute('data-status', status);

        const icon = step.querySelector('.check-icon');
        const detailEl = step.querySelector('.check-detail');

        // Update icon based on status
        switch(status) {
            case 'pending':
                icon.textContent = '‚óã';
                break;
            case 'active':
                icon.textContent = '‚óê';
                break;
            case 'complete':
                icon.textContent = '‚úì';
                break;
            case 'error':
                icon.textContent = '‚úó';
                break;
        }

        // Update detail text (always set, even if empty, to clear old values)
        detailEl.textContent = detail || '';
    }

    // Update rip substeps compact display
    function updateRipSubsteps(ripData) {
        const substepsEl = document.getElementById('rip-substeps');
        const ripStep = ripData.steps ? ripData.steps.rip : null;
        if (!substepsEl || !ripStep) {
            if (substepsEl) substepsEl.innerHTML = '';
            return;
        }

        // Only show substeps when rip step is active or has been active
        if (ripStep.status === 'pending') {
            substepsEl.innerHTML = '';
            return;
        }

        const mode = ripData.rip_mode || 'smart';
        const method = ripData.rip_method || 'direct';
        const directFailed = ripData.direct_failed || false;
        const progress = ripData.progress || 0;
        const detail = ripStep.detail || '';

        // Parse current phase from detail text
        const isBackingUp = detail.toLowerCase().includes('backup') && !detail.toLowerCase().includes('from backup');
        const isExtractingFromBackup = detail.toLowerCase().includes('from backup');
        const isDirect = !isBackingUp && !isExtractingFromBackup && method === 'direct';

        let html = '';

        if (mode === 'always_backup') {
            // Always backup: ‚óê Backup 6% ‚Üí ‚óã Extract
            if (isBackingUp) {
                html = `<span class="substep active">‚óê Backup ${progress}%</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep pending">‚óã Extract</span>`;
            } else if (isExtractingFromBackup) {
                html = `<span class="substep complete">‚úì Backup</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep active">‚óê Extract ${progress}%</span>`;
            } else if (ripStep.status === 'complete') {
                html = `<span class="substep complete">‚úì Backup</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep complete">‚úì Extract</span>`;
            } else if (ripStep.status === 'error') {
                html = `<span class="substep error">‚úó Failed</span>`;
            }
        } else if (mode === 'smart' && directFailed) {
            // Smart with fallback: ‚úó Direct ‚Üí ‚óê Backup 6% ‚Üí ‚óã Extract
            html = `<span class="substep error">‚úó Direct</span>`;
            html += `<span class="substep-arrow">‚Üí</span>`;
            if (isBackingUp) {
                html += `<span class="substep active">‚óê Backup ${progress}%</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep pending">‚óã Extract</span>`;
            } else if (isExtractingFromBackup) {
                html += `<span class="substep complete">‚úì Backup</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep active">‚óê Extract ${progress}%</span>`;
            } else if (ripStep.status === 'complete') {
                html += `<span class="substep complete">‚úì Backup</span>`;
                html += `<span class="substep-arrow">‚Üí</span>`;
                html += `<span class="substep complete">‚úì Extract</span>`;
            } else if (ripStep.status === 'error') {
                html += `<span class="substep error">‚úó Backup failed</span>`;
            }
        } else {
            // Direct only or smart (direct working): ‚óê Direct 45%
            if (ripStep.status === 'active') {
                html = `<span class="substep active">‚óê Direct ${progress}%</span>`;
            } else if (ripStep.status === 'complete') {
                html = `<span class="substep complete">‚úì Direct</span>`;
            } else if (ripStep.status === 'error') {
                html = `<span class="substep error">‚úó Direct failed</span>`;
            }
        }

        substepsEl.innerHTML = html;
    }

    // Start a real rip
    function startRip() {
        const btn = document.getElementById('btn-start-rip');
        btn.disabled = true;
        btn.textContent = 'Starting...';

        // First check if a rip is already running - silently abort if so
        fetch('/api/rip/status')
            .then(r => r.json())
            .then(status => {
                if (status && status.status &&
                    !['idle', 'complete', 'error'].includes(status.status)) {
                    // Already ripping - just update UI to show progress, no error
                    console.log('Rip already in progress, showing status');
                    btn.disabled = false;
                    btn.textContent = 'Start Rip';
                    discAlreadyProcessed = true;
                    return null;
                }

                // Get custom title from input if scan was done
                const titleInput = document.getElementById('custom-title');
                const customTitle = titleInput && titleInput.value ? titleInput.value.trim() : null;

                // Get scan results to check if user corrected the title
                const scanData = getScanResults();

                // Use the user's toggle selection for media type (not auto-detected)
                const isTVDisc = window.currentMediaType === 'tv';

                // Clear scan results since we're starting the rip
                clearScanResults();

                // Build request with scan info for uncertain email logic
                const requestBody = {
                    device: '/dev/sr0',
                    custom_title: customTitle
                };

                // Include scan info so backend knows if title was corrected
                if (scanData) {
                    requestBody.original_suggested = scanData.suggested_title;
                    requestBody.was_uncertain = scanData.needs_review || false;
                    requestBody.disc_label = scanData.disc_label || '';
                    requestBody.runtime_str = scanData.runtime_str || '';
                    requestBody.confidence = scanData.identified ? scanData.identified.confidence : 0;
                }

                // Add TV-specific parameters
                if (isTVDisc) {
                    requestBody.media_type = 'tv';
                    requestBody.season_number = parseInt(document.getElementById('season-number').value) || 1;
                    requestBody.selected_tracks = getSelectedEpisodeTracks();
                    requestBody.episode_mapping = scanData.episode_mapping || {};
                    requestBody.series_title = customTitle || scanData.suggested_title || '';

                    // Validate that at least one episode is selected
                    if (requestBody.selected_tracks.length === 0) {
                        showToast('Please select at least one episode to rip', 'error');
                        btn.disabled = false;
                        btn.textContent = 'Select Episodes';
                        return null;
                    }
                } else {
                    requestBody.media_type = 'movie';
                }

                return fetch('/api/rip/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                }).then(r => r.json());
            })
            .then(data => {
                if (!data) return; // Already ripping, handled above
                if (data.success) {
                    // Rip started, status polling will update UI
                    discAlreadyProcessed = true;
                } else {
                    // Only show error if it's not "already ripping"
                    if (!data.error || !data.error.includes('Already')) {
                        showToast(data.error || 'Could not start rip', 'error');
                    }
                    btn.disabled = false;
                    btn.textContent = 'Start Rip';
                }
            })
            .catch(err => {
                showToast('Error starting rip', 'error');
                btn.disabled = false;
                btn.textContent = 'Start Rip';
            });
    }

    // Reset/cancel current rip
    function resetRip() {
        showingScanResults = false;  // Clear scan results flag
        fetch('/api/rip/reset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    // Reset UI
                    document.getElementById('btn-start-rip').disabled = false;
                    document.getElementById('btn-start-rip').textContent = 'Start Rip';
                    document.getElementById('btn-reset-rip').style.display = 'none';
                    document.getElementById('btn-stop').style.display = 'none';
                    document.getElementById('rip-checklist').style.display = 'none';
                    document.getElementById('rip-progress').style.display = 'none';
                    document.getElementById('status-idle').style.display = 'block';
                    // Reset all steps
                    ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'].forEach(step => {
                        updateStep(step, 'pending', '');
                    });
                }
            });
    }

    function resetDriveState() {
        showToast('Resetting drive state...', 'info');
        fetch('/api/drive/reset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    showToast('Drive reset complete. Disc present: ' + data.disc_present, 'success');
                    // Hide recovery buttons
                    document.getElementById('btn-reset-drive').style.display = 'none';
                    document.getElementById('btn-restart-service').style.display = 'none';
                } else {
                    showToast('Drive reset failed: ' + (data.error || 'Unknown error'), 'error');
                }
            })
            .catch(err => {
                showToast('Drive reset failed: ' + err, 'error');
            });
    }

    function ejectDisc() {
        fetch('/api/drive/eject', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    showToast('Disc ejected', 'success');
                    // Disable eject button since disc is now ejected
                    document.getElementById("btn-eject").disabled = true;
                } else {
                    showToast('Eject failed: ' + (data.error || 'Unknown error'), 'error');
                }
            })
            .catch(err => {
                showToast('Eject failed: ' + err, 'error');
            });
    }

    function restartService() {
        showConfirm(
            'This will restart the RipForge service. The page will reload automatically. Continue?',
            function() {
                showToast('Restarting service...', 'info');
                fetch('/api/service/restart', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            showToast('Service restarting. Page will reload in 5 seconds...', 'success');
                            setTimeout(() => window.location.reload(), 5000);
                        } else {
                            showToast('Restart failed: ' + (data.error || 'Unknown error'), 'error');
                        }
                    })
                    .catch(err => {
                        // Service might have restarted, try reloading anyway
                        showToast('Reloading page...', 'info');
                        setTimeout(() => window.location.reload(), 3000);
                    });
            },
            'Restart Service',
            'Restart'
        );
    }


    function confirmStopDrive() {
        showConfirm(
            'This will stop any scanning or ripping in progress and eject the disc. Continue?',
            stopDrive,
            'Stop Drive',
            'Stop'
        );
    }

    function stopDrive() {
        const btn = document.getElementById('btn-stop');
        btn.disabled = true;
        btn.textContent = 'Stopping...';

        fetch('/api/drive/stop', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    const msg = data.ejected ? 'Stopped and disc ejected' : 'Stopped';
                    showToast(msg, 'info');
                    // Reset UI
                    document.getElementById('btn-start-rip').disabled = false;
                    document.getElementById('btn-start-rip').textContent = 'Start Rip';
                    document.getElementById('btn-stop').style.display = 'none';
                    document.getElementById('rip-checklist').style.display = 'none';
                    document.getElementById('rip-progress').style.display = 'none';
                    document.getElementById('status-idle').style.display = 'block';
                    document.getElementById('btn-eject').disabled = data.ejected === true;
                    showingScanResults = false;
                    // Reset all steps
                    ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'].forEach(step => {
                        updateStep(step, 'pending', '');
                    });
                } else {
                    showToast('Failed to stop', 'error');
                }
            })
            .catch(err => {
                showToast('Error stopping', 'error');
            })
            .finally(() => {
                btn.disabled = false;
                btn.textContent = 'Stop';
            });
    }

    // Scan disc info and identify
    function scanDisc() {
        const btn = document.getElementById('btn-scan-disc');
        const startBtn = document.getElementById('btn-start-rip');
        btn.disabled = true;
        btn.textContent = 'Scanning...';
        startBtn.disabled = true;  // Can't start rip while scanning
        scanInProgress = true;

        // Show stop button and disable eject during scan
        document.getElementById('btn-stop').style.display = 'inline-block';
        document.getElementById('btn-eject').disabled = true;

        // Update status area to show scanning with spinner
        const statusTitle = document.querySelector('.status-title');
        const statusSubtitle = document.querySelector('.status-subtitle');
        const statusIcon = document.getElementById('status-icon');

        statusTitle.textContent = 'Scanning...';
        statusSubtitle.textContent = 'Reading disc and identifying content';
        statusIcon.classList.add('scanning');
        statusIcon.innerHTML = '<div class="scan-spinner"></div>';

        // Hide previous scan results while scanning
        document.getElementById('scan-results').style.display = 'none';

        fetch('/api/disc/scan-identify')
            .then(r => r.json())
            .then(data => {
                scanInProgress = false;
                if (data.error) {
                    // No disc or error
                    statusTitle.textContent = 'No Disc';
                    statusSubtitle.textContent = data.error || 'Insert a disc and try again';
                    clearScanResults();
                } else if (data.disc_label) {
                    // Found a disc - save and display results
                    saveScanResults(data);
                    displayScanResults(data);
                } else {
                    statusTitle.textContent = 'No Disc';
                    statusSubtitle.textContent = 'Insert a disc and try again';
                    clearScanResults();
                }
            })
            .catch(err => {
                scanInProgress = false;
                statusTitle.textContent = 'Scan Error';
                statusSubtitle.textContent = err.message || 'Could not read disc';
                clearScanResults();
            })
            .finally(() => {
                btn.disabled = false;
                btn.textContent = 'Scan Disc';
                startBtn.disabled = false;  // Re-enable Start Rip
                // Reset icon
                statusIcon.classList.remove('scanning');
                statusIcon.innerHTML = 'üìÄ';
                // Hide stop button after scan completes (rip status will show it again if needed)
                ripActions.style.display = 'none';
                stopBtn.style.display = 'none';
            });
    }

    // Hands-free mode: start rip with automatic TV detection
    function startHandsFreeRip(discLabel) {
        // Update UI to show we're starting
        const statusTitle = document.querySelector('.status-title');
        const statusSubtitle = document.querySelector('.status-subtitle');
        statusTitle.textContent = 'Detecting Disc...';
        statusSubtitle.textContent = discLabel || 'Getting disc info...';

        // First get disc info to detect if it's a TV disc
        fetch('/api/disc/info')
            .then(r => r.json())
            .then(info => {
                const isTVDisc = info.is_tv_disc || false;
                const episodeTracks = info.episode_tracks || [];

                // Build rip request
                const requestBody = {
                    device: '/dev/sr0',
                    custom_title: null,  // Let post-rip identification determine title
                    hands_free: true
                };

                if (isTVDisc && episodeTracks.length > 0) {
                    // TV disc - rip all episode tracks
                    requestBody.media_type = 'tv';
                    requestBody.season_number = 1;  // Default, will be corrected in post-ID
                    requestBody.selected_tracks = episodeTracks.map(t => t.index);
                    requestBody.series_title = info.disc_label || '';

                    statusTitle.textContent = 'Starting TV Rip...';
                    statusSubtitle.textContent = `${episodeTracks.length} episodes detected`;
                    console.log('Hands-free: TV disc detected, ripping', episodeTracks.length, 'episodes');
                } else {
                    // Movie disc - rip main feature
                    requestBody.media_type = 'movie';

                    statusTitle.textContent = 'Starting Rip...';
                    statusSubtitle.textContent = discLabel || 'Ripping main feature';
                    console.log('Hands-free: Movie disc, ripping main feature');
                }

                // Start the rip
                return fetch('/api/rip/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    console.log('Hands-free rip started');
                } else {
                    console.error('Error starting hands-free rip:', data.error);
                    statusTitle.textContent = 'Error';
                    statusSubtitle.textContent = data.error || 'Could not start rip';
                }
            })
            .catch(err => {
                console.error('Error starting hands-free rip:', err);
                statusTitle.textContent = 'Error';
                statusSubtitle.textContent = 'Could not start rip';
            });
    }

    // ========================
    // Review Queue Functions
    // ========================
    let currentReviewItem = null;
    let currentSearchResult = null;
    let currentReviewMediaType = 'movie';  // Track toggle state

    function loadReviewQueue() {
        fetch('/api/review/queue')
            .then(r => r.json())
            .then(data => {
                const section = document.getElementById('review-queue-section');
                const container = document.getElementById('review-items');
                const countEl = document.getElementById('review-count');

                if (data.items && data.items.length > 0) {
                    section.style.display = 'block';
                    countEl.textContent = data.items.length;

                    let html = '';
                    data.items.forEach(item => {
                        html += `
                            <div class="review-item" data-folder="${escapeHtml(item.folder_name)}">
                                <div class="review-item-info">
                                    <div class="review-item-title">${escapeHtml(item.fallback_title || item.disc_label)}</div>
                                    <div class="review-item-details">
                                        <span class="disc-type">${(item.disc_type || 'unknown').toUpperCase()}</span>
                                        <span class="runtime">${item.runtime_str || '-'}</span>
                                        <span class="size">${item.size_gb ? item.size_gb + ' GB' : ''}</span>
                                    </div>
                                </div>
                                <button class="btn btn-primary btn-small" onclick="openReviewModal('${escapeHtml(item.folder_name)}')">
                                    Identify
                                </button>
                            </div>
                        `;
                    });
                    container.innerHTML = html;

                    // Store items for modal access
                    window.reviewItems = data.items.reduce((acc, item) => {
                        acc[item.folder_name] = item;
                        return acc;
                    }, {});
                } else {
                    section.style.display = 'none';
                }
            })
            .catch(err => {
                console.error('Error loading review queue:', err);
            });
    }

    function openReviewModal(folderName) {
        const item = window.reviewItems[folderName];
        if (!item) return;

        currentReviewItem = item;
        currentSearchResult = null;

        // Populate modal with item details
        document.getElementById('modal-disc-label').textContent = item.disc_label || '-';
        document.getElementById('modal-runtime').textContent = item.runtime_str || '-';
        document.getElementById('modal-size').textContent = item.size_gb ? item.size_gb + ' GB' : '-';
        document.getElementById('modal-disc-type').textContent = (item.disc_type || 'unknown').toUpperCase();

        // Pre-fill search with fallback title
        document.getElementById('review-search-input').value = item.fallback_title || '';

        // Handle duplicate comparison section
        const dupSection = document.getElementById('duplicate-comparison');
        if (item.possible_duplicate && item.duplicate_info) {
            const existing = item.duplicate_info;
            document.getElementById('dup-existing-title').textContent = existing.title || '-';
            document.getElementById('dup-existing-year').textContent = existing.year || '-';
            document.getElementById('dup-existing-type').textContent = (existing.disc_type || 'unknown').toUpperCase();
            document.getElementById('dup-existing-size').textContent = existing.size_gb ? existing.size_gb + ' GB' : '-';
            document.getElementById('dup-existing-date').textContent = existing.ripped_date ? new Date(existing.ripped_date).toLocaleDateString() : '-';

            document.getElementById('dup-new-title').textContent = item.fallback_title || '-';
            document.getElementById('dup-new-year').textContent = item.year || '-';
            document.getElementById('dup-new-type').textContent = (item.disc_type || 'unknown').toUpperCase();
            document.getElementById('dup-new-size').textContent = item.size_gb ? item.size_gb + ' GB' : '-';
            document.getElementById('dup-new-disc').textContent = item.disc_label || '-';

            dupSection.style.display = 'block';
        } else {
            dupSection.style.display = 'none';
        }

        // Reset results and manual entry
        document.getElementById('review-results').style.display = 'none';
        document.getElementById('review-results').innerHTML = '';
        document.getElementById('manual-entry').style.display = 'none';
        document.getElementById('manual-title').value = '';
        document.getElementById('manual-year').value = '';
        document.getElementById('manual-tmdb').value = '';
        document.getElementById('manual-preview-text').textContent = '-';
        document.getElementById('btn-tmdb-lookup').style.display = 'none';
        document.getElementById('btn-apply-review').disabled = true;
        window.searchResults = null;
        window.tmdbLookupResult = null;

        // Initialize media type toggle based on item's media type
        const initialType = item.media_type || 'movie';
        setReviewMediaType(initialType, false);  // false = don't trigger search

        // Populate episode assignment UI if item has tracks
        populateEpisodeAssignment(item);

        // Show modal
        document.getElementById('review-modal').style.display = 'flex';
    }

    function populateEpisodeAssignment(item) {
        const assignmentSection = document.getElementById('episode-assignment');
        const trackList = document.getElementById('track-list');
        const countSpan = document.getElementById('episode-count');

        // Only show for TV items with tracks
        if (item.media_type !== 'tv' || !item.tracks || item.tracks.length === 0) {
            assignmentSection.style.display = 'none';
            return;
        }

        // Update count text
        const trackCount = item.tracks.length;
        const expectedEps = item.expected_episodes || trackCount;
        countSpan.textContent = `${trackCount} tracks / ${expectedEps} episodes in S${item.season_number || 1}`;

        // Get starting episode from input
        const startEp = parseInt(document.getElementById('tv-start-episode').value) || 1;

        // Build track cards
        let html = '';
        item.tracks.forEach((track, idx) => {
            const duration = formatDuration(track.duration_secs);
            const size = formatSize(track.size_bytes);
            const suggested = track.suggested_episode || (idx + 1);
            const isExtra = track.is_extra || false;

            // Handle multiple thumbnails (new format) or single thumbnail (legacy)
            const thumbnails = track.thumbnails || (track.thumbnail ? [track.thumbnail] : []);
            const hasMetadata = track.metadata && (track.metadata.title || (track.metadata.chapters && track.metadata.chapters.length > 0));

            // Build thumbnail filmstrip HTML with click-to-expand
            let thumbHtml = '';
            if (thumbnails.length > 0) {
                const thumbUrls = thumbnails.map(t => `/api/review/thumbnail/${item.folder_name}/${t}`);
                thumbHtml = `
                    <div class="track-thumb-filmstrip" data-thumbs='${JSON.stringify(thumbUrls)}' data-current="0" data-filename="${escapeHtml(track.filename)}" onclick="openThumbLightbox(this)">
                        <img src="${thumbUrls[0]}" class="track-thumb" alt="Track ${idx + 1}">
                        ${thumbnails.length > 1 ? `<div class="thumb-indicator">${thumbnails.length} frames</div>` : ''}
                    </div>
                `;
            } else {
                thumbHtml = `<div class="track-thumb-placeholder">?</div>`;
            }

            // Build metadata tooltip - check if metadata is actually useful
            let metadataHtml = '';
            if (hasMetadata) {
                const meta = track.metadata;
                let tooltipLines = [];

                // Check if title is meaningful (not just "Chapter XX" generic pattern)
                const genericPattern = /^chapter\s*\d+$/i;
                const titleIsUseful = meta.title && !genericPattern.test(meta.title.trim());

                // Check if any chapter names are meaningful
                let chaptersAreUseful = false;
                if (meta.chapters && meta.chapters.length > 0) {
                    chaptersAreUseful = meta.chapters.some(ch =>
                        ch.title && !genericPattern.test(ch.title.trim())
                    );
                }

                const hasUsefulMetadata = titleIsUseful || chaptersAreUseful;

                if (meta.title) {
                    tooltipLines.push(`Title: ${meta.title}`);
                }
                if (meta.chapters && meta.chapters.length > 0) {
                    tooltipLines.push(`Chapters (${meta.chapters.length}):`);
                    meta.chapters.slice(0, 5).forEach((ch, i) => {
                        tooltipLines.push(`  ${i + 1}. ${ch.title}`);
                    });
                    if (meta.chapters.length > 5) {
                        tooltipLines.push(`  ... and ${meta.chapters.length - 5} more`);
                    }
                }
                const tooltipText = tooltipLines.join('\n');
                const iconClass = hasUsefulMetadata ? 'track-meta-icon' : 'track-meta-icon disabled';
                metadataHtml = `<span class="${iconClass}" title="${escapeHtml(tooltipText)}">‚Ñπ</span>`;
            }

            // Episode number for this track based on starting episode
            const epNum = startEp + idx;

            html += `
                <div class="track-card" data-filename="${escapeHtml(track.filename)}" data-idx="${idx}">
                    ${thumbHtml}
                    <div class="track-info">
                        <span class="track-filename">${escapeHtml(track.filename)}${metadataHtml}</span>
                        <span class="track-meta">${duration} &bull; ${size}</span>
                    </div>
                    <div class="track-assign">
                        <select class="episode-select" data-idx="${idx}" onchange="updateTrackAssignment(${idx}, this.value)">
                            <option value="0" ${isExtra ? 'selected' : ''}>-- Extra --</option>
                            ${generateEpisodeOptions(trackCount, idx + 1, isExtra, startEp)}
                        </select>
                    </div>
                </div>
            `;
        });

        trackList.innerHTML = html;
        assignmentSection.style.display = 'block';

        // Set up thumbnail cycling on hover
        setupThumbnailCycling();
    }

    function openThumbLightbox(filmstrip) {
        const thumbs = JSON.parse(filmstrip.dataset.thumbs || '[]');
        const filename = filmstrip.dataset.filename || 'Track';
        if (thumbs.length === 0) return;

        // Create lightbox
        const lightbox = document.createElement('div');
        lightbox.className = 'thumb-lightbox';
        lightbox.innerHTML = `
            <div class="thumb-lightbox-content">
                <div class="thumb-lightbox-header">
                    <span>${escapeHtml(filename)}</span>
                    <button onclick="this.closest('.thumb-lightbox').remove()">&times;</button>
                </div>
                <div class="thumb-lightbox-grid">
                    ${thumbs.map((url, i) => `<img src="${url}" alt="Frame ${i + 1}">`).join('')}
                </div>
            </div>
        `;
        lightbox.addEventListener('click', (e) => {
            if (e.target === lightbox) lightbox.remove();
        });
        document.body.appendChild(lightbox);
    }

    function setupThumbnailCycling() {
        document.querySelectorAll('.track-thumb-filmstrip').forEach(filmstrip => {
            let interval = null;
            const thumbsData = JSON.parse(filmstrip.dataset.thumbs || '[]');
            if (thumbsData.length <= 1) return;

            const img = filmstrip.querySelector('.track-thumb');

            filmstrip.addEventListener('mouseenter', () => {
                let current = 0;
                interval = setInterval(() => {
                    current = (current + 1) % thumbsData.length;
                    img.src = thumbsData[current];
                    filmstrip.dataset.current = current;
                }, 800);  // Cycle every 800ms
            });

            filmstrip.addEventListener('mouseleave', () => {
                if (interval) {
                    clearInterval(interval);
                    interval = null;
                }
                // Reset to first thumbnail
                img.src = thumbsData[0];
                filmstrip.dataset.current = 0;
            });
        });
    }

    function generateEpisodeOptions(numTracks, selectedIdx, isExtra, startEpisode) {
        let options = '';
        const start = startEpisode || 1;
        for (let i = 0; i < numTracks; i++) {
            const epNum = start + i;
            const isSelected = !isExtra && (i + 1) === selectedIdx;
            options += `<option value="${epNum}" ${isSelected ? 'selected' : ''}>Episode ${epNum}</option>`;
        }
        return options;
    }

    function refreshEpisodeDropdowns() {
        // Re-render dropdowns when starting episode changes
        if (currentReviewItem && currentReviewItem.tracks) {
            const startEp = parseInt(document.getElementById('tv-start-episode').value) || 1;
            const numTracks = currentReviewItem.tracks.length;

            document.querySelectorAll('.episode-select').forEach((select, idx) => {
                const currentVal = select.value;
                const isExtra = currentVal === '0';
                let html = '<option value="0"' + (isExtra ? ' selected' : '') + '>-- Extra --</option>';
                for (let i = 0; i < numTracks; i++) {
                    const epNum = startEp + i;
                    const isSelected = !isExtra && epNum === parseInt(currentVal);
                    html += `<option value="${epNum}" ${isSelected ? 'selected' : ''}>Episode ${epNum}</option>`;
                }
                select.innerHTML = html;
            });
        }
    }

    function updateTrackAssignment(trackIdx, episodeNum) {
        if (!currentReviewItem || !currentReviewItem.tracks) return;
        const track = currentReviewItem.tracks[trackIdx];
        if (track) {
            track.suggested_episode = parseInt(episodeNum);
            track.is_extra = parseInt(episodeNum) === 0;
        }
    }

    function formatDuration(secs) {
        if (!secs) return '--:--';
        const mins = Math.floor(secs / 60);
        const seconds = secs % 60;
        return `${mins}:${seconds.toString().padStart(2, '0')}`;
    }

    function formatSize(bytes) {
        if (!bytes) return '-';
        const gb = bytes / (1024 * 1024 * 1024);
        return gb >= 1 ? `${gb.toFixed(1)} GB` : `${(bytes / (1024 * 1024)).toFixed(0)} MB`;
    }

    function getEpisodeAssignments() {
        // Build episode assignments array from current track data
        if (!currentReviewItem || !currentReviewItem.tracks) return [];

        return currentReviewItem.tracks.map(track => ({
            filename: track.filename,
            episode_num: track.suggested_episode || 0,
            is_extra: track.is_extra || (track.suggested_episode === 0)
        }));
    }

    function setReviewMediaType(type, triggerSearch = true) {
        currentReviewMediaType = type;

        // Update toggle button states
        document.getElementById('toggle-movie').classList.toggle('active', type === 'movie');
        document.getElementById('toggle-tv').classList.toggle('active', type === 'tv');

        // Show/hide TV options
        document.getElementById('tv-options').style.display = type === 'tv' ? 'block' : 'none';

        // Show/hide episode assignment (only for TV with tracks)
        if (type === 'tv' && currentReviewItem && currentReviewItem.tracks && currentReviewItem.tracks.length > 0) {
            populateEpisodeAssignment(currentReviewItem);
        } else {
            document.getElementById('episode-assignment').style.display = 'none';
        }

        // Update search hint
        const hint = document.getElementById('search-hint');
        if (type === 'tv') {
            hint.textContent = 'Results from Sonarr/TVDB. Click IMDB/TVDB links to verify.';
        } else {
            hint.textContent = 'Results from Radarr/TMDB. Click IMDB/TMDB links to verify.';
        }

        // Clear previous results when switching types
        if (triggerSearch) {
            document.getElementById('review-results').style.display = 'none';
            document.getElementById('review-results').innerHTML = '';
            currentSearchResult = null;
            window.searchResults = null;
            document.getElementById('btn-apply-review').disabled = true;

            // Auto-search if there's a query
            const query = document.getElementById('review-search-input').value.trim();
            if (query) {
                searchReviewTitle();
            }
        }
    }

    function toggleManualEntry() {
        const el = document.getElementById('manual-entry');
        const isHidden = el.style.display === 'none';
        el.style.display = isHidden ? 'block' : 'none';
        if (isHidden) {
            document.getElementById('manual-title').focus();
        }
    }

    function updateManualPreview() {
        const title = document.getElementById('manual-title').value.trim();
        const year = document.getElementById('manual-year').value.trim();
        const preview = document.getElementById('manual-preview-text');
        const applyBtn = document.getElementById('btn-apply-review');

        if (title) {
            preview.textContent = year ? `${title} (${year})` : title;
            applyBtn.disabled = false;
        } else {
            preview.textContent = '-';
            // Only disable if no search result either
            if (!currentSearchResult) {
                applyBtn.disabled = true;
            }
        }
    }

    // Wire up manual entry input events
    document.addEventListener('DOMContentLoaded', function() {
        const titleInput = document.getElementById('manual-title');
        const yearInput = document.getElementById('manual-year');
        const tmdbInput = document.getElementById('manual-tmdb');
        const startEpInput = document.getElementById('tv-start-episode');

        if (titleInput) titleInput.addEventListener('input', updateManualPreview);
        if (yearInput) yearInput.addEventListener('input', updateManualPreview);
        if (tmdbInput) tmdbInput.addEventListener('input', function() {
            updateManualPreview();
            // Show/hide fetch button based on TMDB ID
            const fetchBtn = document.getElementById('btn-tmdb-lookup');
            if (fetchBtn) {
                fetchBtn.style.display = this.value.trim() ? 'inline-block' : 'none';
            }
        });

        // Refresh episode dropdowns when starting episode changes
        if (startEpInput) startEpInput.addEventListener('change', refreshEpisodeDropdowns);
    });

    function lookupTmdbId() {
        const tmdbId = document.getElementById('manual-tmdb').value.trim();
        if (!tmdbId) return;

        const btn = document.getElementById('btn-tmdb-lookup');
        btn.disabled = true;
        btn.textContent = 'Fetching...';

        fetch('/api/review/tmdb-lookup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tmdb_id: parseInt(tmdbId) })
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    // Fill in the fields from TMDB data
                    document.getElementById('manual-title').value = data.title || '';
                    document.getElementById('manual-year').value = data.year || '';
                    updateManualPreview();

                    // Store the fetched data for apply
                    window.tmdbLookupResult = data;
                    showToast(`Found: ${data.title} (${data.year})`, 'success');
                    document.getElementById('btn-apply-review').disabled = false;
                } else {
                    showToast(data.error || 'TMDB lookup failed', 'error');
                }
            })
            .catch(err => {
                console.error('TMDB lookup error:', err);
                showToast('TMDB lookup failed', 'error');
            })
            .finally(() => {
                btn.disabled = false;
                btn.textContent = 'Fetch Info';
            });
    }

    function closeReviewModal() {
        document.getElementById('review-modal').style.display = 'none';
        currentReviewItem = null;
        currentSearchResult = null;
    }

    // Duplicate resolution actions
    function keepNewRip() {
        if (!currentReviewItem) return;

        const dupInfo = currentReviewItem.duplicate_info || {};
        const title = dupInfo.title || 'item';

        showConfirm(
            `This will REPLACE the existing "${title}" in your library with the new rip.`,
            function() {
                fetch('/api/review/duplicate/keep-new', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder_name: currentReviewItem.folder_name,
                        existing_path: dupInfo.path || ''
                    })
                })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            showToast('Replaced existing with new rip', 'success');
                            closeReviewModal();
                            loadReviewQueue();
                        } else {
                            showToast(data.error || 'Failed to replace', 'error');
                        }
                    })
                    .catch(err => {
                        console.error('Keep new error:', err);
                        showToast('Failed to replace existing rip', 'error');
                    });
            },
            'Replace Existing?',
            'Replace'
        );
    }

    function keepExistingRip() {
        if (!currentReviewItem) return;

        showConfirm(
            'This will DELETE the new rip and keep your existing library item.',
            function() {
                fetch('/api/review/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder_name: currentReviewItem.folder_name
                    })
                })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            showToast('Kept existing, new rip deleted', 'success');
                            closeReviewModal();
                            loadReviewQueue();
                        } else {
                            showToast(data.error || 'Failed to delete new rip', 'error');
                        }
                    })
                    .catch(err => {
                        console.error('Keep existing error:', err);
                        showToast('Failed to delete new rip', 'error');
                    });
            },
            'Delete New Rip?',
            'Delete'
        );
    }

    function keepBothRips() {
        if (!currentReviewItem) return;

        // Keep both = move new to library with a suffix (e.g., disc type or date)
        const dupInfo = currentReviewItem.duplicate_info || {};
        const discType = (currentReviewItem.disc_type || 'unknown').toUpperCase();

        fetch('/api/review/duplicate/keep-both', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                folder_name: currentReviewItem.folder_name
            })
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    showToast(`Added to library as: ${data.new_title || 'new copy'}`, 'success');
                    closeReviewModal();
                    loadReviewQueue();
                } else {
                    showToast(data.error || 'Failed to keep both', 'error');
                }
            })
            .catch(err => {
                console.error('Keep both error:', err);
                showToast('Failed to add new rip to library', 'error');
            });
    }

    function searchReviewTitle() {
        const query = document.getElementById('review-search-input').value.trim();
        if (!query || !currentReviewItem) return;

        const btn = event.target;
        btn.disabled = true;
        btn.textContent = 'Searching...';

        const mediaType = currentReviewMediaType || 'movie';

        fetch('/api/review/search', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                query: query,
                runtime_seconds: currentReviewItem.runtime_seconds || 0,
                media_type: mediaType
            })
        })
            .then(r => r.json())
            .then(data => {
                if (data.results && data.results.length > 0) {
                    // Store all results
                    window.searchResults = data.results;
                    currentSearchResult = null;

                    // Render multiple result cards - different links for TV vs Movie
                    const container = document.getElementById('review-results');
                    container.style.display = 'block';
                    container.innerHTML = data.results.map((result, idx) => {
                        const isTV = mediaType === 'tv';
                        const dbLink = isTV
                            ? (result.tvdb_id ? `<a href="https://thetvdb.com/series/${result.tvdb_id}" target="_blank" class="verify-link" onclick="event.stopPropagation()">TVDB ‚Üó</a>` : '')
                            : (result.tmdb_id ? `<a href="https://www.themoviedb.org/movie/${result.tmdb_id}" target="_blank" class="verify-link" onclick="event.stopPropagation()">TMDB ‚Üó</a>` : '');
                        const imdbLink = result.imdb_id ? `<a href="https://www.imdb.com/title/${result.imdb_id}/" target="_blank" class="verify-link" onclick="event.stopPropagation()">IMDB ‚Üó</a>` : '';

                        return `
                        <div class="result-card" data-idx="${idx}" onclick="selectSearchResult(${idx})">
                            ${result.poster_url
                                ? `<img class="result-poster" src="${result.poster_url}" alt="Poster">`
                                : `<div class="result-poster-placeholder">?</div>`
                            }
                            <div class="result-info">
                                <div class="result-title">${escapeHtml(result.title || '-')}</div>
                                <div class="result-meta">
                                    <span>${result.year || '-'}</span>
                                    ${!isTV ? ` &bull; <span>${result.runtime_minutes ? result.runtime_minutes + ' min' : '-'}</span>` : ''}
                                </div>
                                <div class="result-links">
                                    ${dbLink}
                                    ${imdbLink}
                                </div>
                            </div>
                        </div>
                    `}).join('');

                    // Auto-select first result
                    selectSearchResult(0);
                } else {
                    document.getElementById('review-results').style.display = 'none';
                    currentSearchResult = null;
                    document.getElementById('btn-apply-review').disabled = true;
                    showToast('No results found. Try a different search or enter manually.', 'info');
                }
            })
            .catch(err => {
                console.error('Search error:', err);
                showToast('Search failed. Please try again.', 'error');
            })
            .finally(() => {
                btn.disabled = false;
                btn.textContent = 'Search';
            });
    }

    function selectSearchResult(idx) {
        const results = window.searchResults || [];
        if (idx < 0 || idx >= results.length) return;

        currentSearchResult = results[idx];

        // Update selected state visually
        document.querySelectorAll('.result-card').forEach((card, i) => {
            card.classList.toggle('selected', i === idx);
        });

        // Clear manual entry when selecting a search result
        document.getElementById('manual-title').value = '';
        document.getElementById('manual-year').value = '';
        document.getElementById('manual-tmdb').value = '';
        updateManualPreview();

        document.getElementById('btn-apply-review').disabled = false;
    }

    function applyReviewIdentification() {
        if (!currentReviewItem) return;

        // Check for manual entry first
        const manualTitle = document.getElementById('manual-title').value.trim();
        const manualYear = document.getElementById('manual-year').value.trim();

        const mediaType = currentReviewMediaType || 'movie';
        const isTV = mediaType === 'tv';

        // Get TV-specific fields
        const seasonNum = isTV ? parseInt(document.getElementById('tv-season').value) || 1 : null;
        const startEpisode = isTV ? parseInt(document.getElementById('tv-start-episode').value) || 1 : null;

        let payload;
        let folderNameForToast;

        if (manualTitle) {
            // Use manual entry - check if we have TMDB lookup data
            const tmdbData = window.tmdbLookupResult;
            const manualTmdbId = document.getElementById('manual-tmdb').value.trim();

            folderNameForToast = manualYear ? `${manualTitle} (${manualYear})` : manualTitle;
            payload = {
                folder_name: currentReviewItem.folder_name,
                identified_title: folderNameForToast,
                media_type: mediaType,
                year: manualYear ? parseInt(manualYear) : 0,
                tmdb_id: (tmdbData && tmdbData.tmdb_id) ? tmdbData.tmdb_id : (manualTmdbId ? parseInt(manualTmdbId) : 0),
                poster_url: (tmdbData && tmdbData.poster_url) ? tmdbData.poster_url : ''
            };
            // Add TV-specific fields
            if (isTV) {
                payload.season_number = seasonNum;
                payload.start_episode = startEpisode;
                payload.episode_assignments = getEpisodeAssignments();
            }
            // Clear the lookup result after use
            window.tmdbLookupResult = null;
        } else if (currentSearchResult) {
            // Use search result
            folderNameForToast = currentSearchResult.folder_name;
            payload = {
                folder_name: currentReviewItem.folder_name,
                identified_title: currentSearchResult.folder_name,
                media_type: mediaType,
                year: currentSearchResult.year || 0,
                tmdb_id: currentSearchResult.tmdb_id || 0,
                tvdb_id: currentSearchResult.tvdb_id || 0,
                poster_url: currentSearchResult.poster_url || ''
            };
            // Add TV-specific fields
            if (isTV) {
                payload.season_number = seasonNum;
                payload.start_episode = startEpisode;
                payload.episode_assignments = getEpisodeAssignments();
            }
        } else {
            return;  // Nothing to apply
        }

        const btn = document.getElementById('btn-apply-review');
        btn.disabled = true;
        btn.textContent = 'Applying...';

        fetch('/api/review/apply', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    const folderName = folderNameForToast;  // Save before closing modal
                    closeReviewModal();
                    loadReviewQueue();  // Refresh the queue
                    loadActivityLog();  // Refresh activity log
                    showToast(`Moved to library: ${folderName}`, 'success');
                } else {
                    showToast(data.error || 'Could not apply identification', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Apply Identification';
                }
            })
            .catch(err => {
                console.error('Apply error:', err);
                showToast('Error applying identification. Please try again.', 'error');
                btn.disabled = false;
                btn.textContent = 'Apply Identification';
            });
    }

    function deleteReviewItem() {
        if (!currentReviewItem) return;

        showConfirm(
            'Are you sure you want to delete this rip? This cannot be undone.',
            function() {
                fetch('/api/review/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder_name: currentReviewItem.folder_name
                    })
                })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            closeReviewModal();
                            loadReviewQueue();
                            loadActivityLog();
                            showToast('Deleted from review queue', 'info');
                        } else {
                            showToast(data.error || 'Could not delete item', 'error');
                        }
                    })
                    .catch(err => {
                        console.error('Delete error:', err);
                        showToast('Error deleting item. Please try again.', 'error');
                    });
            },
            'Delete Rip',
            'Delete'
        );
    }

    // Custom confirm modal
    let confirmCallback = null;

    function showConfirm(message, onConfirm, title = 'Confirm', okText = 'Delete') {
        document.getElementById('confirm-title').textContent = title;
        document.getElementById('confirm-message').textContent = message;
        document.getElementById('confirm-ok').textContent = okText;
        confirmCallback = onConfirm;
        document.getElementById('confirm-modal').style.display = 'flex';
    }

    function closeConfirm() {
        document.getElementById('confirm-modal').style.display = 'none';
        confirmCallback = null;
    }

    document.getElementById('confirm-cancel').addEventListener('click', closeConfirm);
    document.getElementById('confirm-ok').addEventListener('click', function() {
        if (confirmCallback) confirmCallback();
        closeConfirm();
    });

    // Close modals on escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            if (document.getElementById('review-modal').style.display === 'flex') {
                closeReviewModal();
            }
            if (document.getElementById('confirm-modal').style.display === 'flex') {
                closeConfirm();
            }
        }
    });

    // Close modals on overlay click
    document.getElementById('review-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeReviewModal();
        }
    });

    document.getElementById('confirm-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeConfirm();
        }
    });

    // Demo function to test the UI (can be called from console)
    function demoRip() {
        const steps = ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'];
        let currentStep = 0;

        document.getElementById('status-idle').style.display = 'none';
        document.getElementById('rip-checklist').style.display = 'block';
        document.querySelector('.disc-label').textContent = 'GUARDIANS_VOL_3';

        function advanceStep() {
            if (currentStep > 0) {
                updateStep('step-' + steps[currentStep - 1], 'complete', '');
            }
            if (currentStep < steps.length) {
                updateStep('step-' + steps[currentStep], 'active', 'Processing...');

                // Show progress bar during rip step
                if (steps[currentStep] === 'rip') {
                    document.getElementById('rip-progress').style.display = 'block';
                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress += 10;
                        document.getElementById('progress-fill').style.width = progress + '%';
                        document.getElementById('progress-text').textContent = progress + '%';
                        document.getElementById('progress-eta').textContent = (100 - progress) / 10 + ' min remaining';
                        if (progress >= 100) {
                            clearInterval(progressInterval);
                            document.getElementById('rip-progress').style.display = 'none';
                            currentStep++;
                            setTimeout(advanceStep, 500);
                        }
                    }, 300);
                    return;
                }

                currentStep++;
                setTimeout(advanceStep, 1000);
            } else {
                // All done
                setTimeout(() => {
                    showToast('Rip complete! Movie added to library.', 'success');
                    showIdleState();
                    // Reset all steps
                    steps.forEach(s => updateStep('step-' + s, 'pending', ''));
                }, 500);
            }
        }

        advanceStep();
    }
</script>
{% endblock %}
