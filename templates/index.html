{% extends "base.html" %}

{% block title %}RipForge - Dashboard{% endblock %}
{% block page_title %}Dashboard{% endblock %}

{% block content %}
<div class="dashboard">
    <!-- Current Rip Status -->
    <section class="card rip-status">
        <h2>Current Status</h2>

        <!-- Idle State -->
        <div class="status-idle" id="status-idle">
            <div class="status-display">
                <div class="status-icon idle" id="status-icon">üìÄ</div>
                <div class="status-text">
                    <div class="status-title">Ready</div>
                    <div class="status-subtitle">Insert a disc to begin</div>
                </div>
            </div>

            <!-- Scan Results (hidden until scan completes) -->
            <div class="scan-results" id="scan-results" style="display: none;">
                <div class="scan-info">
                    <span class="scan-disc-type" id="scan-disc-type">DVD</span>
                    <span class="scan-disc-label" id="scan-disc-label">DISC_LABEL</span>
                    <span class="scan-runtime" id="scan-runtime">1:30:00</span>
                </div>
                <div class="scan-title-edit">
                    <label for="custom-title">Title:</label>
                    <input type="text" id="custom-title" class="title-input" placeholder="Movie Title (Year)">
                    <span class="confidence-badge" id="confidence-badge" style="display: none;">HIGH</span>
                    <a href="#" id="imdb-search-btn" class="btn btn-small" target="_blank" title="Search IMDB">IMDB</a>
                </div>

                <!-- Identification Methods Debug -->
                <div class="id-methods" id="id-methods" style="display: none;">
                    <div class="id-methods-header">
                        <span class="id-methods-toggle" onclick="toggleIdMethods()">Identification Details</span>
                    </div>
                    <div class="id-methods-list" id="id-methods-list"></div>
                </div>

                <!-- Auto-rip countdown -->
                <div class="auto-rip-countdown" id="auto-rip-countdown" style="display: none;">
                    <div class="countdown-ring">
                        <svg viewBox="0 0 100 100">
                            <circle class="countdown-bg" cx="50" cy="50" r="45"></circle>
                            <circle class="countdown-progress" cx="50" cy="50" r="45" id="countdown-circle"></circle>
                        </svg>
                        <span class="countdown-number" id="countdown-number">10</span>
                    </div>
                    <div class="countdown-text">
                        <span>Auto-rip in <strong id="countdown-seconds">10</strong>s</span>
                        <button class="btn btn-small btn-secondary" onclick="cancelCountdown()">Cancel</button>
                    </div>
                </div>
            </div>

            <div class="status-actions">
                <button class="btn btn-primary" id="btn-start-rip" onclick="startRip()">
                    Start Rip
                </button>
                <button class="btn btn-secondary" id="btn-scan-disc" onclick="scanDisc()">
                    Scan Disc
                </button>
                <button class="btn btn-danger" id="btn-reset-rip" onclick="resetRip()" style="display: none;">
                    Reset
                </button>
            </div>
        </div>

        <!-- Active Rip Checklist -->
        <div class="rip-checklist" id="rip-checklist" style="display: none;">
            <div class="rip-title" id="rip-title">
                <span class="disc-label">Processing disc...</span>
                <span class="current-step" id="current-step"></span>
            </div>

            <div class="checklist">
                <div class="checklist-item" id="step-insert" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Disc inserted</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-detect" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Detecting disc type</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-scan" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Scanning tracks</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-rip" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Ripping main feature</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-identify" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Identifying content</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-library" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Adding to library</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-move" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Moving to destination</span>
                    <span class="check-detail"></span>
                </div>
                <div class="checklist-item" id="step-scan-plex" data-status="pending">
                    <span class="check-icon">‚óã</span>
                    <span class="check-text">Triggering Plex scan</span>
                    <span class="check-detail"></span>
                </div>
            </div>

            <!-- Progress bar for current step -->
            <div class="rip-progress" id="rip-progress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="progress-info">
                    <span id="progress-text">0%</span>
                    <span id="progress-eta"></span>
                </div>
            </div>

            <!-- Actions for rip in progress -->
            <div class="rip-actions" id="rip-actions" style="display: none; margin-top: 1rem; text-align: center;">
                <button class="btn btn-danger" onclick="resetRip()">Reset</button>
            </div>
        </div>
    </section>

    <!-- Hardware Flex Card -->
    <section class="card hardware-flex">
        <div class="hardware-header">
            <div class="ripforge-brand">
                <span class="brand-icon">üî•</span>
                <span class="brand-name">RipForge</span>
            </div>
            <span class="hardware-hostname" id="hw-hostname">-</span>
        </div>
        <div class="hardware-list" id="hardware-list">
            <div class="hw-row">
                <span class="hw-label">CPU</span>
                <span class="hw-value" id="hw-cpu">Detecting...</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">Memory</span>
                <span class="hw-value" id="hw-ram">-</span>
            </div>
            <div class="hw-row" id="hw-gpu-row" style="display: none;">
                <span class="hw-label">GPU</span>
                <span class="hw-value" id="hw-gpu">-</span>
            </div>
            <div id="hw-storage-rows">
                <!-- Storage rows will be inserted here dynamically -->
            </div>
            <div class="hw-row">
                <span class="hw-label">Optical Drive</span>
                <span class="hw-value" id="hw-optical">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">IP Address</span>
                <span class="hw-value" id="hw-ip">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">Uptime</span>
                <span class="hw-value" id="hw-uptime">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">OS</span>
                <span class="hw-value" id="hw-os">-</span>
            </div>
            <div class="hw-row">
                <span class="hw-label">Docker</span>
                <span class="hw-value" id="hw-docker">-</span>
            </div>
        </div>
    </section>

    <!-- Quick Stats + Integrations -->
    <section class="card stats">
        <h2>Quick Stats</h2>
        <div class="stats-grid">
            <div class="stat">
                <div class="stat-value" id="stat-today">0</div>
                <div class="stat-label">Ripped Today</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="stat-week">0</div>
                <div class="stat-label">This Week</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="stat-total">0</div>
                <div class="stat-label">All Time</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="stat-errors">0</div>
                <div class="stat-label">Errors</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="stat-avg-bluray">--</div>
                <div class="stat-label">Avg Blu-ray</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="stat-avg-dvd">--</div>
                <div class="stat-label">Avg DVD</div>
            </div>
        </div>
        <div class="integration-strip" id="integration-list">
            <div class="integration-dot" title="Radarr">
                <span class="integration-status" id="int-radarr">‚óè</span>
                <span class="integration-label">Radarr</span>
            </div>
            <div class="integration-dot" title="Sonarr">
                <span class="integration-status" id="int-sonarr">‚óè</span>
                <span class="integration-label">Sonarr</span>
            </div>
            <div class="integration-dot" title="Overseerr">
                <span class="integration-status" id="int-overseerr">‚óè</span>
                <span class="integration-label">Overseerr</span>
            </div>
            <div class="integration-dot" title="Plex">
                <span class="integration-status" id="int-plex">‚óè</span>
                <span class="integration-label">Plex</span>
            </div>
        </div>
    </section>

    <!-- Activity Log -->
    <section class="card activity-log full-width">
        <div class="log-header">
            <h2>Activity Log</h2>
            <div class="log-filters">
                <button class="log-filter active" data-filter="all">All</button>
                <button class="log-filter" data-filter="info">Info</button>
                <button class="log-filter" data-filter="error">Errors</button>
            </div>
        </div>
        <div class="log-container" id="log-container">
            <div class="log-entry info">
                <span class="log-time">--:--:--</span>
                <span class="log-level">INFO</span>
                <span class="log-message">Waiting for activity...</span>
            </div>
        </div>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Load status on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadStatus();
        loadHardware();
        loadActivityLog();
        loadRipStats();
        restoreScanResults();  // Restore scan results from session
        startDiscPolling();    // Start polling for disc insertion
        // Refresh status every 2 seconds (faster for progress bar updates)
        setInterval(loadStatus, 2000);
        // Refresh activity log every 5 seconds
        setInterval(loadActivityLog, 5000);
        // Refresh stats every 30 seconds
        setInterval(loadRipStats, 30000);

        // Setup log filter buttons
        document.querySelectorAll('.log-filter').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.log-filter').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                document.getElementById('log-container').setAttribute('data-filter', this.dataset.filter);
            });
        });
    });

    // Load activity log
    function loadActivityLog() {
        fetch('/api/activity-log')
            .then(r => r.json())
            .then(data => {
                const container = document.getElementById('log-container');
                if (!data.log || data.log.length === 0) {
                    container.innerHTML = `
                        <div class="log-entry info">
                            <span class="log-time">--:--:--</span>
                            <span class="log-level">INFO</span>
                            <span class="log-message">No activity logged yet</span>
                        </div>
                    `;
                    return;
                }

                let html = '';
                data.log.forEach(entry => {
                    // Parse log entry format: "YYYY-MM-DD HH:MM:SS | LEVEL | message"
                    // or fallback to simple text
                    let time = '--:--:--';
                    let level = 'info';
                    let message = entry;

                    const match = entry.match(/^(\d{4}-\d{2}-\d{2}\s+)?(\d{2}:\d{2}:\d{2})?\s*\|?\s*(INFO|ERROR|WARN|SUCCESS|DEBUG)?\s*\|?\s*(.*)$/i);
                    if (match) {
                        time = match[2] || '--:--:--';
                        level = (match[3] || 'info').toLowerCase();
                        message = match[4] || entry;
                    }

                    // Map log levels
                    if (level === 'warn') level = 'warning';

                    html += `
                        <div class="log-entry ${level}">
                            <span class="log-time">${time}</span>
                            <span class="log-level">${level.toUpperCase()}</span>
                            <span class="log-message">${escapeHtml(message)}</span>
                        </div>
                    `;
                });

                container.innerHTML = html;
            })
            .catch(err => {
                console.error('Error loading activity log:', err);
            });
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Load rip statistics
    function loadRipStats() {
        fetch('/api/rip-stats')
            .then(r => r.json())
            .then(data => {
                document.getElementById('stat-today').textContent = data.today || 0;
                document.getElementById('stat-week').textContent = data.week || 0;
                document.getElementById('stat-total').textContent = data.total || 0;
                document.getElementById('stat-errors').textContent = data.errors || 0;

                // Format average times as "XXm"
                const avgBluray = document.getElementById('stat-avg-bluray');
                const avgDvd = document.getElementById('stat-avg-dvd');

                if (data.avg_bluray_mins !== null) {
                    avgBluray.textContent = data.avg_bluray_mins + 'm';
                } else {
                    avgBluray.textContent = '--';
                }

                if (data.avg_dvd_mins !== null) {
                    avgDvd.textContent = data.avg_dvd_mins + 'm';
                } else {
                    avgDvd.textContent = '--';
                }
            })
            .catch(err => console.error('Error loading rip stats:', err));
    }

    // Restore scan results from sessionStorage (persists across tab switches)
    function restoreScanResults() {
        const saved = sessionStorage.getItem('scanResults');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                displayScanResults(data);
            } catch (e) {
                console.error('Error restoring scan results:', e);
            }
        }
    }

    // Save scan results to sessionStorage
    function saveScanResults(data) {
        sessionStorage.setItem('scanResults', JSON.stringify(data));
    }

    // Clear scan results
    function clearScanResults() {
        sessionStorage.removeItem('scanResults');
        document.getElementById('scan-results').style.display = 'none';
        document.getElementById('auto-rip-countdown').style.display = 'none';
        showingScanResults = false;
        cancelCountdown();
    }

    // Display scan results in the UI
    function displayScanResults(data) {
        showingScanResults = true;

        // Update status text
        const statusTitle = document.querySelector('.status-title');
        const statusSubtitle = document.querySelector('.status-subtitle');

        if (data.identified) {
            statusTitle.textContent = data.identified.title;
            statusSubtitle.textContent = `Identified with ${data.identified.confidence}% confidence`;
        } else {
            statusTitle.textContent = data.parsed_search || data.disc_label;
            statusSubtitle.textContent = 'Could not auto-identify - please verify title';
        }

        // Show scan results section
        const scanResults = document.getElementById('scan-results');
        scanResults.style.display = 'block';

        // Fill in disc info
        document.getElementById('scan-disc-type').textContent = (data.disc_type || 'DISC').toUpperCase();
        document.getElementById('scan-disc-label').textContent = data.disc_label;

        // Runtime
        if (data.main_feature !== null && data.tracks) {
            const track = data.tracks.find(t => t.index === data.main_feature);
            if (track) {
                document.getElementById('scan-runtime').textContent = track.duration_str;
            }
        }

        // Fill in editable title
        const titleInput = document.getElementById('custom-title');
        titleInput.value = data.suggested_title || data.parsed_search || data.disc_label;

        // Show confidence badge if identified
        const badge = document.getElementById('confidence-badge');
        if (data.identified && data.identified.confidence) {
            badge.style.display = 'inline';
            if (data.identified.confidence >= 75) {
                badge.textContent = 'HIGH';
                badge.className = 'confidence-badge high';
            } else if (data.identified.confidence >= 50) {
                badge.textContent = 'MEDIUM';
                badge.className = 'confidence-badge medium';
            } else {
                badge.textContent = 'LOW';
                badge.className = 'confidence-badge low';
            }
        } else {
            badge.style.display = 'none';
        }

        // Show identification methods debug info
        const methodsContainer = document.getElementById('id-methods');
        const methodsList = document.getElementById('id-methods-list');
        if (data.identification_methods && data.identification_methods.length > 0) {
            methodsContainer.style.display = 'block';
            let html = '';
            data.identification_methods.forEach(method => {
                const confClass = method.confidence >= 75 ? 'high' : (method.confidence >= 50 ? 'medium' : 'low');
                html += `
                    <div class="id-method">
                        <div class="id-method-header">
                            <span class="id-method-name">${method.method}</span>
                            <span class="id-method-conf ${confClass}">${method.confidence}%</span>
                        </div>
                        <div class="id-method-result">${method.result}</div>
                        <div class="id-method-details">${method.details}</div>
                    </div>
                `;
            });
            methodsList.innerHTML = html;
        } else {
            methodsContainer.style.display = 'none';
        }

        // Set IMDB search link
        const imdbBtn = document.getElementById('imdb-search-btn');
        const searchTerm = data.parsed_search || data.disc_label.replace(/_/g, ' ');
        imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(searchTerm)}&s=tt&ttype=ft`;

        // Update IMDB link when title input changes
        titleInput.addEventListener('input', function() {
            const term = this.value.trim() || searchTerm;
            imdbBtn.href = `https://www.imdb.com/find/?q=${encodeURIComponent(term)}&s=tt&ttype=ft`;
            // Cancel countdown if user is editing
            cancelCountdown();
        });

        // Only start auto-rip countdown if confident identification
        // If needs_review is true, wait for user to confirm
        if (data.needs_review) {
            // Show review needed banner
            statusSubtitle.textContent = '‚ö†Ô∏è Low confidence - please verify title before ripping';
        } else {
            // Start auto-rip countdown
            startCountdown();
        }
    }

    function loadHardware() {
        fetch('/api/hardware')
            .then(r => r.json())
            .then(data => {
                document.getElementById('hw-hostname').textContent = data.hostname || '-';
                document.getElementById('hw-cpu').textContent = data.cpu + (data.cpu_cores ? ' (' + data.cpu_cores + ' cores)' : '');
                document.getElementById('hw-ram').textContent = data.ram_used_gb + ' / ' + data.ram_gb + ' GB';
                document.getElementById('hw-os').textContent = data.os || '-';
                document.getElementById('hw-ip').textContent = data.ip_address || '-';
                document.getElementById('hw-uptime').textContent = data.uptime || '-';
                document.getElementById('hw-docker').textContent = data.docker_version || '-';

                // GPU (only show if present)
                if (data.gpu) {
                    document.getElementById('hw-gpu').textContent = data.gpu;
                    document.getElementById('hw-gpu-row').style.display = 'flex';
                }

                // Storage drives
                const storageContainer = document.getElementById('hw-storage-rows');
                storageContainer.innerHTML = '';
                if (data.storage && data.storage.length > 0) {
                    data.storage.forEach(drive => {
                        const row = document.createElement('div');
                        row.className = 'hw-row';
                        // Format: "media (HDD)" or "storage (SSD)"
                        let label = drive.mount.replace('/mnt/', '').replace('/media/', '');
                        if (drive.type) {
                            label += ` <span class="drive-type">${drive.type}</span>`;
                        }
                        // Fix df's 1% minimum - show 0% if used is tiny (KB range)
                        let percent = drive.percent;
                        if (drive.used.endsWith('K') && percent === '1%') {
                            percent = '0%';
                        }
                        row.innerHTML = `
                            <span class="hw-label">${label}</span>
                            <span class="hw-value">${drive.used} / ${drive.size} (${percent})</span>
                        `;
                        storageContainer.appendChild(row);
                    });
                } else if (data.disk_total) {
                    // Fallback to single media drive
                    const row = document.createElement('div');
                    row.className = 'hw-row';
                    row.innerHTML = `
                        <span class="hw-label">Media</span>
                        <span class="hw-value">${data.disk_used} / ${data.disk_total} (${data.disk_percent}%)</span>
                    `;
                    storageContainer.appendChild(row);
                }

                // Optical drive
                if (data.optical_drives && data.optical_drives.length > 0) {
                    document.getElementById('hw-optical').textContent = data.optical_drives[0].model || data.optical_drives[0].device;
                }
            })
            .catch(err => console.error('Error loading hardware:', err));
    }

    function loadStatus() {
        fetch('/api/status')
            .then(r => r.json())
            .then(data => {
                // Update integration status
                for (const [service, status] of Object.entries(data.integrations)) {
                    const el = document.getElementById('int-' + service);
                    if (el) {
                        if (!status.enabled) {
                            el.className = 'integration-status disabled';
                            el.textContent = '‚óã';
                        } else if (status.connected) {
                            el.className = 'integration-status connected';
                            el.textContent = '‚óè';
                        } else {
                            el.className = 'integration-status error';
                            el.textContent = '‚óè';
                        }
                    }
                }

                // Update rip status
                if (data.ripping) {
                    showRipProgress(data.ripping);
                } else {
                    showIdleState();
                }
            })
            .catch(err => console.error('Error loading status:', err));
    }

    // Checklist UI Functions
    // Track if we're showing scan results (don't overwrite with idle)
    let showingScanResults = false;
    // Track if scan is in progress (don't let polling reset UI)
    let scanInProgress = false;
    // Auto-rip countdown
    let countdownInterval = null;
    let countdownSeconds = 20;
    const AUTO_RIP_ENABLED = {{ config.get('ripping', {}).get('auto_rip', true) | tojson }};
    const AUTO_RIP_DELAY = {{ config.get('ripping', {}).get('auto_rip_delay', 20) }};
    const AUTO_SCAN_ON_INSERT = {{ config.get('ripping', {}).get('auto_scan_on_insert', true) | tojson }};

    // Disc insert polling
    let lastDiscState = false;
    let discPollInterval = null;
    let discAlreadyProcessed = false;  // Track if current disc was already scanned/ripped

    function startDiscPolling() {
        if (!AUTO_SCAN_ON_INSERT) return;

        discPollInterval = setInterval(() => {
            // Don't poll if scan is in progress
            if (scanInProgress) return;

            // First check if a rip is already running
            fetch('/api/rip/status')
                .then(r => r.json())
                .then(ripStatus => {
                    // If rip is active, mark disc as processed and don't scan
                    if (ripStatus && ripStatus.status &&
                        !['idle', 'complete', 'error'].includes(ripStatus.status)) {
                        discAlreadyProcessed = true;
                        return null; // Skip disc check
                    }
                    return fetch('/api/disc/check').then(r => r.json());
                })
                .then(data => {
                    if (!data) return; // Skipped because rip is running

                    const discPresent = data.present;

                    // Disc was ejected - reset the processed flag
                    if (!discPresent && lastDiscState) {
                        console.log('Disc ejected, ready for new disc');
                        discAlreadyProcessed = false;
                        showingScanResults = false;
                        clearScanResults();
                    }

                    // Detect disc insertion (was not present, now present, not already processed)
                    if (discPresent && !lastDiscState && !discAlreadyProcessed) {
                        console.log('Disc inserted, auto-scanning...');
                        discAlreadyProcessed = true;
                        scanDisc();
                    }

                    lastDiscState = discPresent;
                })
                .catch(() => {});
        }, 2000); // Poll every 2 seconds
    }

    function stopDiscPolling() {
        if (discPollInterval) {
            clearInterval(discPollInterval);
            discPollInterval = null;
        }
    }

    function startCountdown() {
        if (!AUTO_RIP_ENABLED) return;

        countdownSeconds = AUTO_RIP_DELAY;
        const countdownEl = document.getElementById('auto-rip-countdown');
        const numberEl = document.getElementById('countdown-number');
        const secondsEl = document.getElementById('countdown-seconds');
        const circleEl = document.getElementById('countdown-circle');

        // Show countdown
        countdownEl.style.display = 'flex';

        // Calculate circle circumference (2 * PI * r)
        const circumference = 2 * Math.PI * 45;
        circleEl.style.strokeDasharray = circumference;

        function updateCountdown() {
            numberEl.textContent = countdownSeconds;
            secondsEl.textContent = countdownSeconds;

            // Update ring progress
            const progress = countdownSeconds / AUTO_RIP_DELAY;
            const offset = circumference * (1 - progress);
            circleEl.style.strokeDashoffset = offset;

            if (countdownSeconds <= 0) {
                cancelCountdown();
                startRip();
            } else {
                countdownSeconds--;
            }
        }

        updateCountdown();
        countdownInterval = setInterval(updateCountdown, 1000);
    }

    function cancelCountdown() {
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }
        document.getElementById('auto-rip-countdown').style.display = 'none';
    }

    function showIdleState() {
        document.getElementById('status-idle').style.display = 'block';
        document.getElementById('rip-checklist').style.display = 'none';

        // Only reset to "Ready" if not showing scan results and not scanning
        if (!showingScanResults && !scanInProgress) {
            document.querySelector('.status-title').textContent = 'Ready';
            document.querySelector('.status-subtitle').textContent = 'Insert a disc to begin';
        }
    }

    function showRipProgress(ripData) {
        document.getElementById('status-idle').style.display = 'none';
        document.getElementById('rip-checklist').style.display = 'block';

        // Update disc label
        document.querySelector('.disc-label').textContent = ripData.disc_label || 'Processing disc...';

        // Update each step and find current active step
        const steps = ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'];
        const stepNames = {
            'insert': 'Inserting',
            'detect': 'Detecting',
            'scan': 'Scanning',
            'rip': 'Ripping',
            'identify': 'Identifying',
            'library': 'Library',
            'move': 'Moving',
            'scan-plex': 'Plex Scan'
        };
        let currentStepName = '';
        steps.forEach(step => {
            const stepData = ripData.steps ? ripData.steps[step] : null;
            if (stepData) {
                updateStep('step-' + step, stepData.status, stepData.detail);
                if (stepData.status === 'active') {
                    currentStepName = stepNames[step] || step;
                }
            }
        });

        // Show current step or completion status
        const currentStepEl = document.getElementById('current-step');
        if (ripData.status === 'complete') {
            currentStepEl.textContent = 'Complete';
            currentStepEl.className = 'current-step complete';
        } else if (ripData.status === 'error') {
            currentStepEl.textContent = 'Error';
            currentStepEl.className = 'current-step error';
        } else if (currentStepName) {
            currentStepEl.textContent = currentStepName;
            currentStepEl.className = 'current-step active';
        } else {
            currentStepEl.textContent = '';
        }

        // Update progress bar if ripping (show when rip step is active or progress > 0)
        const ripStepActive = ripData.steps && ripData.steps.rip && ripData.steps.rip.status === 'active';
        if (ripStepActive || (ripData.progress !== undefined && ripData.progress > 0)) {
            document.getElementById('rip-progress').style.display = 'block';
            const pct = ripData.progress || 0;
            document.getElementById('progress-fill').style.width = pct + '%';
            document.getElementById('progress-text').textContent = pct + '%';
            if (ripData.eta) {
                document.getElementById('progress-eta').textContent = ripData.eta;
            } else if (pct === 0) {
                document.getElementById('progress-eta').textContent = 'Starting...';
            }
        } else {
            document.getElementById('rip-progress').style.display = 'none';
        }

        // Show reset button on error or complete
        const resetBtn = document.getElementById('btn-reset-rip');
        const ripActions = document.getElementById('rip-actions');
        if (ripData.status === 'error' || ripData.status === 'complete') {
            resetBtn.style.display = 'inline-block';
            ripActions.style.display = 'block';
            document.getElementById('btn-start-rip').disabled = false;
            document.getElementById('btn-start-rip').textContent = 'Start Rip';
        } else {
            resetBtn.style.display = 'none';
            ripActions.style.display = 'none';
        }
    }

    function updateStep(stepId, status, detail) {
        const step = document.getElementById(stepId);
        if (!step) return;

        step.setAttribute('data-status', status);

        const icon = step.querySelector('.check-icon');
        const detailEl = step.querySelector('.check-detail');

        // Update icon based on status
        switch(status) {
            case 'pending':
                icon.textContent = '‚óã';
                break;
            case 'active':
                icon.textContent = '‚óê';
                break;
            case 'complete':
                icon.textContent = '‚úì';
                break;
            case 'error':
                icon.textContent = '‚úó';
                break;
        }

        // Update detail text (always set, even if empty, to clear old values)
        detailEl.textContent = detail || '';
    }

    // Start a real rip
    function startRip() {
        const btn = document.getElementById('btn-start-rip');
        btn.disabled = true;
        btn.textContent = 'Starting...';

        // First check if a rip is already running - silently abort if so
        fetch('/api/rip/status')
            .then(r => r.json())
            .then(status => {
                if (status && status.status &&
                    !['idle', 'complete', 'error'].includes(status.status)) {
                    // Already ripping - just update UI to show progress, no error
                    console.log('Rip already in progress, showing status');
                    btn.disabled = false;
                    btn.textContent = 'Start Rip';
                    discAlreadyProcessed = true;
                    return null;
                }

                // Get custom title from input if scan was done
                const titleInput = document.getElementById('custom-title');
                const customTitle = titleInput && titleInput.value ? titleInput.value.trim() : null;

                // Clear scan results since we're starting the rip
                clearScanResults();

                return fetch('/api/rip/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        device: '/dev/sr0',
                        custom_title: customTitle
                    })
                }).then(r => r.json());
            })
            .then(data => {
                if (!data) return; // Already ripping, handled above
                if (data.success) {
                    // Rip started, status polling will update UI
                    discAlreadyProcessed = true;
                } else {
                    // Only show error if it's not "already ripping"
                    if (!data.error || !data.error.includes('Already')) {
                        alert('Error: ' + (data.error || 'Could not start rip'));
                    }
                    btn.disabled = false;
                    btn.textContent = 'Start Rip';
                }
            })
            .catch(err => {
                alert('Error starting rip');
                btn.disabled = false;
                btn.textContent = 'Start Rip';
            });
    }

    // Reset/cancel current rip
    function resetRip() {
        showingScanResults = false;  // Clear scan results flag
        fetch('/api/rip/reset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    // Reset UI
                    document.getElementById('btn-start-rip').disabled = false;
                    document.getElementById('btn-start-rip').textContent = 'Start Rip';
                    document.getElementById('btn-reset-rip').style.display = 'none';
                    document.getElementById('rip-actions').style.display = 'none';
                    document.getElementById('rip-checklist').style.display = 'none';
                    document.getElementById('rip-progress').style.display = 'none';
                    document.getElementById('status-idle').style.display = 'block';
                    // Reset all steps
                    ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'].forEach(step => {
                        updateStep(step, 'pending', '');
                    });
                }
            });
    }

    // Scan disc info and identify
    function scanDisc() {
        const btn = document.getElementById('btn-scan-disc');
        btn.disabled = true;
        btn.textContent = 'Scanning...';
        scanInProgress = true;

        // Update status area to show scanning with spinner
        const statusTitle = document.querySelector('.status-title');
        const statusSubtitle = document.querySelector('.status-subtitle');
        const statusIcon = document.getElementById('status-icon');

        statusTitle.textContent = 'Scanning...';
        statusSubtitle.textContent = 'Reading disc and identifying content';
        statusIcon.classList.add('scanning');
        statusIcon.innerHTML = '<div class="scan-spinner"></div>';

        // Hide previous scan results while scanning
        document.getElementById('scan-results').style.display = 'none';

        fetch('/api/disc/scan-identify')
            .then(r => r.json())
            .then(data => {
                scanInProgress = false;
                if (data.error) {
                    // No disc or error
                    statusTitle.textContent = 'No Disc';
                    statusSubtitle.textContent = data.error || 'Insert a disc and try again';
                    clearScanResults();
                } else if (data.disc_label) {
                    // Found a disc - save and display results
                    saveScanResults(data);
                    displayScanResults(data);
                } else {
                    statusTitle.textContent = 'No Disc';
                    statusSubtitle.textContent = 'Insert a disc and try again';
                    clearScanResults();
                }
            })
            .catch(err => {
                scanInProgress = false;
                statusTitle.textContent = 'Scan Error';
                statusSubtitle.textContent = err.message || 'Could not read disc';
                clearScanResults();
            })
            .finally(() => {
                btn.disabled = false;
                btn.textContent = 'Scan Disc';
                // Reset icon
                statusIcon.classList.remove('scanning');
                statusIcon.innerHTML = 'üìÄ';
            });
    }

    // Demo function to test the UI (can be called from console)
    function demoRip() {
        const steps = ['insert', 'detect', 'scan', 'rip', 'identify', 'library', 'move', 'scan-plex'];
        let currentStep = 0;

        document.getElementById('status-idle').style.display = 'none';
        document.getElementById('rip-checklist').style.display = 'block';
        document.querySelector('.disc-label').textContent = 'GUARDIANS_VOL_3';

        function advanceStep() {
            if (currentStep > 0) {
                updateStep('step-' + steps[currentStep - 1], 'complete', '');
            }
            if (currentStep < steps.length) {
                updateStep('step-' + steps[currentStep], 'active', 'Processing...');

                // Show progress bar during rip step
                if (steps[currentStep] === 'rip') {
                    document.getElementById('rip-progress').style.display = 'block';
                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress += 10;
                        document.getElementById('progress-fill').style.width = progress + '%';
                        document.getElementById('progress-text').textContent = progress + '%';
                        document.getElementById('progress-eta').textContent = (100 - progress) / 10 + ' min remaining';
                        if (progress >= 100) {
                            clearInterval(progressInterval);
                            document.getElementById('rip-progress').style.display = 'none';
                            currentStep++;
                            setTimeout(advanceStep, 500);
                        }
                    }, 300);
                    return;
                }

                currentStep++;
                setTimeout(advanceStep, 1000);
            } else {
                // All done
                setTimeout(() => {
                    alert('Rip complete! Movie added to library.');
                    showIdleState();
                    // Reset all steps
                    steps.forEach(s => updateStep('step-' + s, 'pending', ''));
                }, 500);
            }
        }

        advanceStep();
    }
</script>
{% endblock %}
